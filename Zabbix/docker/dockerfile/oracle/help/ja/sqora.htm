<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja"><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-Script-Type" content="text/javascript" />

<title>Oracle ODBC Driverの使用方法</title><meta name="generator" content="Oracle DARB XHTML Converter (Mode = browser help) - Version 5.1.2 Build 708" />
<meta name="date" content="2013-03-15T11:44:58Z" />
<meta name="robots" content="noarchive" />
<meta name="doctitle" content="Using the Oracle ODBC Driver" />
<meta name="relnum" content="" />
<meta name="partnum" content="" />
<link rel="copyright" href="cpyr.htm" title="Copyright" type="text/html" />
<link rel="stylesheet" href="blafdoc.css" title="Oracle BLAFDoc" type="text/css" />
<link rel="contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="prev" href="toc.htm" title="Previous" type="text/html" /></head>

<body>
<div class="header"><a id="top" name="top"></a>
<div class="zz-skip-header"><a href="#BEGIN">ヘッダーをスキップ</a></div>
<table cellpadding="0" cellspacing="0" class="simple oac_no_warn" summary="" width="100%">
<tbody><tr>
<td align="left" valign="top"><br />
<br /></td>
<td align="right" valign="bottom">
<table cellpadding="0" cellspacing="0" class="simple oac_no_warn" summary="">
<tbody><tr>
<td>&nbsp;</td>
<td align="right" valign="top"><a href="toc.htm"><br /> <span class="icon">目次</span></a></td>
</tr>
</tbody></table>
</td>
</tr>
</tbody></table>
<hr />
<table cellpadding="0" cellspacing="0" class="simple oac_no_warn" summary="" width="100">
<tbody><tr>
<td align="center"><a href="toc.htm"><br /> <span class="icon">戻る</span></a>&nbsp;</td>
<td>&nbsp;</td>
</tr>
</tbody></table>
<a name="BEGIN" id="BEGIN"></a></div>
<!-- class="header" -->
<div class="ind"><!-- End Header -->
<script type="text/javascript">
<!-- // <![CDATA[
window.name='sqora'
// ]]> -->
</script> <script type="text/javascript">
// <![CDATA[
function footdisplay(footnum,footnote) {
    var msg = window.open('', 'NewWindow' + footnum,
        'directories=no,height=120,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');

    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">');
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><title>');
    msg.document.write('Footnote ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('<meta http-equiv="Content-Script-Type" ');
    msg.document.write('content="text/javascript" />');
    msg.document.write('<style type="text/css"> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]\u003e <\/style>');
    msg.document.write('<\/head><body><h1>Footnote ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/body><\/html>');
    msg.document.close();
    msg.focus();
}
// ]]>
</script> <noscript>
<p>このページのスクリプト・コンテンツはナビゲーションのみを目的としており、いかなる方法においても内容を変更するものではありません。</p>
</noscript><a id="BABGJEHF" name="BABGJEHF"></a><a id="ADFNS1112" name="ADFNS1112"></a>
<p class="alphabetanotice">ベータ版: 2015年07月24日</p>
<h1 style="text-align: center;" class="chapter">Oracle ODBC Driverヘルプ</h1> <span style="font-weight: bold;">バージョン12.2</span>
<h1 class="chapter">Oracle ODBC Driverの使用方法</h1>
<p>このOracle ODBC Driver情報には、次の項があります。</p>
<ul>
<li>
<p><a href="#BABEHFCD">Oracle ODBC Driverについて</a></p>
</li>
<li>
<p><a href="#BABIBGJI">すべてのユーザー</a></p>
</li>
<li>
<p><a href="#BABGFHBE">上級ユーザー</a></p>
</li>
<li>
<p><a href="#BABICHJC">プログラマ</a></p>
</li>
<li>
<p><a href="#BABJHHHH">用語集</a></p>
</li>
<li>
<p><a href="#BABCEBCD">著作権および商標</a></p>
</li>
</ul>
<a id="BABEHFCD" name="BABEHFCD"></a><a id="ADFNS1113" name="ADFNS1113"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Oracle ODBC Driverについて</h2>
<a id="ADFNS1114" name="ADFNS1114"></a>
<p class="subhead2">ODBCとは</p>
<p>Open Database Connectivity (<a href="#BABFCGBI">ODBC</a>)は、1つのアプリケーションが多くの異なるデータソースにアクセスできるようにする標準インタフェースを提供します。アプリケーションのソース・コードは、データソースごとに再コンパイルする必要がありません。データベース・ドライバは、アプリケーションを特定のデータソースにリンクします。データベース・ドライバは、アプリケーションが特定のデータソースにアクセスするためにオンデマンドで呼び出すことのできるダイナミック・リンク・ライブラリです。したがって、アプリケーションはデータベース・ドライバが存在する任意のデータソースにアクセスできます。</p>
<p>ODBCインタフェースには次のものが定義されています。</p>
<ul>
<li>
<p>ODBC関数コールのライブラリ。アプリケーションではこのライブラリを利用してデータソースに接続し、SQL文を実行して結果を取り出すことができます。</p>
</li>
<li>
<p>SQL-99仕様に基づくSQL構文</p>
</li>
<li>
<p>エラー・コードの標準セット</p>
</li>
<li>
<p>データソースへの接続とログインの標準的な方法</p>
</li>
<li>
<p>データ型の標準的な表現</p>
</li>
</ul>
<p><a href="#BABEIGEE">図1-1</a>に、ODBCモデルのコンポーネントを示します。ODBCアプリケーションは、ODBC APIを介してドライバ・マネージャをコールします。ドライバ・マネージャは、Microsoftドライバ・マネージャまたはunixODBCドライバ・マネージャです。ドライバ・マネージャは、ここでもODBC APIを使用してODBCドライバをコールします。ODBCドライバは、データベースAPIを使用し、ネットワーク通信リンク経由でデータベースにアクセスします。<a href="#BABEIGEE">図1-1</a>は、異なる3つのデータベースにアクセスするODBCアプリケーションを示したものです。</p>
<div class="figure"><a id="BABEIGEE" name="BABEIGEE"></a><a id="ADFNS1115" name="ADFNS1115"></a>
<p class="titleinfigure">図1-1 ODBCモデルのコンポーネント</p>
<img alt="図1-1の説明が続きます" longdesc="img_text/odbcmodel.htm" src="img/odbcmodel.gif" /><br /> <a href="img_text/odbcmodel.htm" id="sthref1" name="sthref1">「図1-1 ODBCモデルのコンポーネント」の説明</a><br /> <br /></div>
<!-- class="figure" -->
<a id="ADFNS1116" name="ADFNS1116"></a>
<p class="subhead2">関連トピック</p>
<p><a href="#BABJFIEC">Oracle ODBC Driverとは</a></p>
</div>
<!-- class="sect1" -->
<a id="BABIBGJI" name="BABIBGJI"></a><a id="ADFNS1117" name="ADFNS1117"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">すべてのユーザー</h2>
<ul>
<li>
<p><a href="#BABGEDCB">Oracle ODBC Driver</a></p>
</li>
<li>
<p><a href="#BABGJJAF">構成タスク</a></p>
</li>
<li>
<p><a href="#BABHABJB">oraodbc.iniファイルの変更</a></p>
</li>
<li>
<p><a href="#BABDBDJG">データソースへの接続</a></p>
</li>
<li>
<p><a href="#BABCHDJE">トラブルシューティング</a></p>
</li>
</ul>
<a id="BABGEDCB" name="BABGEDCB"></a><a id="ADFNS1118" name="ADFNS1118"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Oracle ODBC Driver</h3>
<ul>
<li>
<p><a href="#BABJFIEC">Oracle ODBC Driverとは</a></p>
</li>
<li>
<p><a href="#BABCGECE">新機能と変更された機能</a></p>
</li>
<li>
<p><a href="#BABBDJAA">サポートされていない機能</a></p>
</li>
<li>
<p><a href="#BABHEGHC">インストールによって作成されるファイル</a></p>
</li>
<li>
<p><a href="#BABECBDH">ドライバの準拠レベル</a></p>
</li>
<li>
<p><a href="#BABCICCF">既知の制限事項</a></p>
</li>
</ul>
<a id="BABJFIEC" name="BABJFIEC"></a><a id="ADFNS1119" name="ADFNS1119"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Oracle ODBC Driverとは</h4>
<p>Oracle ODBC Driverを使用すると、Microsoft WindowsおよびLinux、Solaris、AIXなどのUNIXプラットフォーム上のアプリケーションで、<a href="#BABFDACF">Oracle Net Services</a>ソフトウェアを使用し、ODBCインタフェースを介して、Oracleデータベースに対する読取りおよび書込みアクセスができます。</p>
<p>Oracle ODBC Driverは、<a href="#BABGCEAA">Oracle Call Interface</a>(OCI)のクライアント/サーバー・ソフトウェアを介して、データソースへの要求の送信およびデータソースからの応答を受信します。OCIクライアントとOracleサーバー間の通信には、Oracle Net Services通信プロトコルが使用されます。</p>
<p>Oracle ODBC Driverは、ODBC <a href="#BABJABEH">SQL</a>構文をデータソースにアクセスできる構文に変換します。データソースから結果が戻されると、Oracle ODBC Driverは戻された結果をODBC SQL構文に変換します。</p>
<p><a href="#BABJEDJJ">図1-2</a>は、前述のOracle ODBC Driverアーキテクチャを示したものです。</p>
<div class="figure"><a id="BABJEDJJ" name="BABJEDJJ"></a><a id="ADFNS1120" name="ADFNS1120"></a>
<p class="titleinfigure">図1-2 Oracle ODBC Driverアーキテクチャ</p>
<img alt="図1-2の説明が続きます" longdesc="img_text/odbcdrvarch.htm" src="img/odbcdrvarch.gif" /><br /> <a href="img_text/odbcdrvarch.htm" id="sthref2" name="sthref2">「図1-2 Oracle ODBC Driverアーキテクチャ」の説明</a><br /> <br /></div>
<!-- class="figure" -->
<p>* Oracle ODBCリソース<a href="#BABIIHGJ">DLL</a>ファイル(<code>sqres</code><code><span class="codeinlineitalic">xx</span></code><code>.dll</code>。<code><span class="codeinlineitalic">xx</span></code>は言語の略称)には、言語に関連する全情報が含まれています。使用されるデフォルトのリソース・ファイルは<code>sqresus.dll</code>です。</p>
<p>OCIクライアント/サーバー・ソフトウェアの詳細は、OCIのマニュアルを参照してください。</p>
<a id="ADFNS1121" name="ADFNS1121"></a>
<p class="subhead2">関連トピック</p>
<p><a href="#BABBCBHH">データソースの構成</a></p>
<p><a href="#BABDBDJG">データソースへの接続</a></p>
<p><a href="#BABECBDH">ドライバの準拠レベル</a></p>
<p><a href="#BABCGECE">新機能と変更された機能</a></p>
<p><a href="#BABHEGHC">インストールによって作成されるファイル</a></p>
</div>
<!-- class="sect3" -->
<a id="BABCGECE" name="BABCGECE"></a><a id="ADFNS1122" name="ADFNS1122"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">新機能と変更された機能</h4>
<ul>
<li>
<p><a href="#BABEDIHI">リリース12.1.0.1.0の新機能</a></p>
</li>
<li>
<p><a href="#BABBFBBG">リリース11.2.0.1.0の新機能</a></p>
</li>
<li>
<p><a href="#BABHBGGB">リリース11.1.0.1.0の新機能</a></p>
</li>
<li>
<p><a href="#BABDABCJ">リリース10.1.0.2.0の新機能</a></p>
</li>
<li>
<p><a href="#BABCCDCJ">リリース10.1.0.2.0の変更点</a></p>
</li>
</ul>
<a id="BABEDIHI" name="BABEDIHI"></a><a id="ADFNS1123" name="ADFNS1123"></a>
<p class="subhead2">リリース12.1.0.1.0の新機能</p>
<p>Microsoft Windows Server 2008、Windows Server 2008 R2、Windows 7、Windows 8、Windows Server 2012、Linux X86-64 (32/64ビット)、Sun Solaris SPARC64 (32/64ビット)、IBM AIX 5L 5.2 (32/64ビット)、Sun Solaris X64 (32/64ビット)、HPUX IA64 (32/64ビット)、ZLinux (32/64ビット)オペレーティング・システム用のOracle ODBC Driverリリース12.1.0.1.0ソフトウェアの機能は次のとおりです。</p>
<ul>
<li>
<p>Oracle ODBC Driverは、<code>VARCHAR2</code>、<code>NVARCHAR2</code>および<code>RAW</code>データで32 KBデータ列をサポートするようになりました。32 KB列の作成の詳細は、<a href="http://www.oracle.com/pls/topic/lookup?ctx=db121&id=LNPLS99943"><span class="italic">Oracle Database PL/SQL言語リファレンス</span></a>および<a href="http://www.oracle.com/pls/topic/lookup?ctx=db121&id=SQLRF55623"><span class="italic">Oracle Database SQL言語リファレンス</span></a>を参照してください。</p>
</li>
<li>
<p><code>odbc.ini</code>ファイルまたは接続レベル属性の新しいパラメータ:</p>
<ul>
<li>
<p>SQL_TRANSLATE_ERRORS= T/F [デフォルトはF (false)]</p>
<p>SQL翻訳フレームワーク機能を使用している移行済のサード・パーティODBCアプリケーションでは、サーバーから返されるエラーがネイティブ・データベース形式を取ると予想されます。ユーザーは、SQL翻訳フレームワーク・モードで稼働しているOracle DatabaseのSQL翻訳プロファイルにエラーの翻訳を登録できます。エラーの翻訳が登録されたら、ODBCアプリケーションのユーザーはオプション<code>SQLTranslateErrors = T</code>を有効化し、登録されているとおりのネイティブ・エラーを受け取ることができます。</p>
<p>SQL翻訳フレームワークの詳細は、<span class="italic">『Oracle Database移行ガイド』</span>、特に<a href="http://www.oracle.com/pls/topic/lookup?ctx=db121&id=DRDAA131">「SQL翻訳フレームワークのアーキテクチャと概要」</a>、<a href="http://www.oracle.com/pls/topic/lookup?ctx=db121&id=DRDAA132">「翻訳フレームのインストールと構成」</a>および<a href="http://www.oracle.com/pls/topic/lookup?ctx=db121&id=DRDAA133">「移行例」</a>を参照してください。</p>
</li>
</ul>
<p>詳細は、<a href="#BABEFBFB">表1-5</a>を参照してください。</p>
</li>
<li>
<p>Oracle ODBCドライバが、<code>RefCursor</code>を使用せずに暗黙的結果を返すことのできるストアド・プロシージャの実行をサポートするようになりました。このサポートにより、Oracleに移行したサード・パーティのODBCアプリケーションで、旧ベンダーが提供していたこの同じ機能を使用しやすくなります。</p>
<p>Oracle Databaseによる暗黙的結果のサポートの詳細は、<a href="http://www.oracle.com/pls/topic/lookup?ctx=db121&id=DRDAA230"><span class="italic">Oracle Database移行ガイド</span></a>を参照してください。</p>
</li>
<li><a id="BABHDJED" name="BABHDJED"></a>
<p>Oracleデータベースの自動増分機能をサポートするためのSQLColAttribute()フィールド識別子の拡張サポート。Oracle ODBC Driver固有のヘッダー・ファイル<code>sqora.h</code>をアプリケーションに含めることで、この機能を使用できます。自動増分の詳細は、<a href="http://www.oracle.com/pls/topic/lookup?ctx=db121&id=LNOCI16468"><span class="italic">『Oracle Call Interfaceプログラマーズ・ガイド』</span></a>を参照してください。</p>
<ul>
<li>
<p><code>SQL_COLUMN_AUTO_INCREMENT</code></p>
<p>Oracle Database 12<span class="italic">c</span>リリース1 (12.1)以降では、Oracleが自動増分列をサポートするため、Oracle ODBC Driverは既存のSQLColAttribute()識別子<code>SQL_COLUMN_AUTO_INCREMENT</code>を通じて同じサポートを拡張しました。このプロパティは読取り専用であり、列が自動増分の場合に<code>SQL_TRUE</code>を返し、それ以外の場合に<code>SQL_FALSE</code>を返します。</p>
</li>
<li>
<p><code>SQL_ORCLATTR_COLUMN_PROP</code></p>
<p>Oracle Database 12<span class="italic">c</span>リリース1 (12.1)以降では、Oracle ODBC Driverは、列の属性を返す新しいドライバ固有フィールド識別子<code>SQL_ORCLATTR_COLUMN_PROP</code>をサポートします。この識別子は、次に示すようにすべての列プロパティを持つ<code>SQLULEN</code>値を返します。</p>
<pre xml:space="preserve" class="oac_no_warn">+-----------------------------------------+<br />| 32 |...| 10 | 9 | 8 |......| 3 | 2 | 1  |<br />+-----------------------------------------+<br />                               |   |   |<br />                               |   |   |-&gt; Column is auto-increment?<br />                               |   |-&gt; Auto value is always generated?<br />                               |-&gt; If generated by default when null?<br /></pre></li>
</ul>
</li>
<li>
<p>Oracle Database 12<span class="italic">c</span>リリース1 (12.1)でサポートされるODBC API</p>
<ul>
<li>
<p>SQLMoreResults()</p>
<p>暗黙的結果のODBCサポートを実装します。詳細は、<a href="#BABHEGBH">「ODBC API関数の実装」</a>の<a href="#BABIIHAC">表1-7</a>および<code><a href="http://msdn.microsoft.com/en-us/library/ms714673%28v=VS.85%29.aspx">http://msdn.microsoft.com/en-us/library/ms714673(v=VS.85).aspx</a></code>を参照してください。</p>
</li>
</ul>
</li>
</ul>
<a id="BABBFBBG" name="BABBFBBG"></a><a id="ADFNS1124" name="ADFNS1124"></a>
<p class="subhead2">リリース11.2.0.1.0の新機能</p>
<p>Microsoft Windows XP、Microsoft Windows 2003 Server、Microsoft Windows Vista、Linux X86-32 (RHEL AS 4、5)、Linux X86-64 (RHEL AS 4、5)(32/64ビット)、Sun Solaris SPARC64 (9、10)(32/64ビット)、IBM AIX 5L 5.2 (32/64ビット)、Linux IA64 (64ビット)、Linux on Power (32/64ビット)、Sun Solaris X64 (64ビット)、Hewlett Packard Itanium (32/64ビット)オペレーティング・システム用のOracle ODBC Driverリリース11.2.0.1.0ソフトウェアの機能は次のとおりです。</p>
<ul>
<li>
<p>LONG/LONG RAWデータのプリフェッチ</p>
<p>Oracle ODBC Driverは、ODBCアプリケーションのパフォーマンスを向上させるために、<code>LONG</code>または<code>LONG RAW</code>データをプリフェッチするように拡張されています。これを行うには、Windowsでは<code>LONG</code>データの最大サイズ(<code>MaxLargeData</code>)をレジストリに設定し(DSNにレジストリ・キー<code>MaxLargeData</code>を追加する必要もあります)、UNIXプラットフォームでは<code>odbc.ini</code>ファイルにこれを手動で設定する必要があります。この機能強化により、ユーザーが設定した<code>MaxLargeData</code>サイズに応じてOracle ODBC Driverのパフォーマンスが最大10倍向上します。<code>MaxLargeData</code>のデフォルト値は0です。設定できる<code>MaxLargeData</code>の最大値は64KB (65536バイト)です。</p>
<p><code>MaxLargeData</code>の値が65536より大きい値に設定されていても、フェッチされるデータは65536バイトのみです。データベースに65536バイトより大きい<code>LONG</code>または<code>LONG RAW</code>データがある場合は、単一行のフェッチが行われ、完全な<code>LONG</code>データがフェッチされるように、<code>MaxLargeData</code>を0 (デフォルト値)に設定する必要があります。ポーリング以外のモードで<code>MaxLargeData</code>サイズより少ないバッファ・サイズを渡すと、データベースの<code>LONG</code>データ・サイズがバッファ・サイズより大きい場合には、データの切捨てエラーが発生します。</p>
</li>
<li>
<p>メタデータをフェッチするための<code>OCIDescribeAny()</code>の使用オプション</p>
<p>アプリケーションが、<code>REF CURSORS</code>を返す小さなパッケージ・プロシージャを大量にコールする場合、ドライバに<code>OCIDescribeAny()</code>の使用を強制することでパフォーマンスを向上させることができます。このオプションを有効にするには、UNIXプラットフォームで、またWindowsではレジストリを使用して、<code>odbc.ini</code>の<code>UseOCIDescribeAny</code>の値を<code>T</code>(True)に設定します。デフォルト値は<code>F</code>(False)です。</p>
</li>
</ul>
<a id="BABHBGGB" name="BABHBGGB"></a><a id="ADFNS1125" name="ADFNS1125"></a>
<p class="subhead2">リリース11.1.0.1.0の新機能</p>
<p>Windows XP、Linux、SolarisおよびAIXオペレーティング・システム用のOracle ODBC Driverリリース11.1.0.1.0ソフトウェアの機能は次のとおりです。</p>
<ul>
<li>
<p>RULEヒントを無効化(DRH接続文字列)</p>
<p>新しい接続オプション「RULEヒントを無効化」が追加されました。これにより、ユーザーは、カタログAPIでRULEヒントを使用するかどうかを選択するオプションを指定できます。カタログAPIのODBCドライバのパフォーマンスを向上させるための変更が行われました。オプションのデフォルト値は、RULEヒントがカタログAPIで使用されないことを意味する<code>TRUE</code>です。</p>
</li>
<li>
<p>NUMBERをFLOATとしてバインド(BNF接続文字列)</p>
<p>新しい接続オプション「NUMBERをFLOATとしてバインド」が追加されました。列に浮動小数点データが含まれる場合に<code>FLOAT</code>としての<code>NUMBER</code>列の列バインディングを導入することにより、バインド変数を<code>FLOAT</code>として使用する問合せ実行が高速になります。</p>
</li>
<li>
<p>文キャッシング</p>
<p>各セッションの文のキャッシュを提供および管理するOCI文キャッシュ機能のサポートが追加されました。OCI文のキャッシュ・オプションのサポートを実装することで、ユーザーが同じ接続で同じ文を複数回解析する必要がある場合にOracle ODBC Driverのパフォーマンスが向上します。文キャッシュ・フラグのデフォルト値は<code>FALSE</code>です。</p>
</li>
</ul>
<a id="BABDABCJ" name="BABDABCJ"></a><a id="ADFNS1126" name="ADFNS1126"></a>
<p class="subhead2">リリース10.1.0.2.0の新機能</p>
<p>Windows 98、Windows 2000、Windows XPおよびWindows NT X86オペレーティング・システム用のOracle ODBC Driverリリース10.1.0.2.0ソフトウェアの機能は次のとおりです。</p>
<ul>
<li>
<p><code>TIMESTAMP</code>を<code>DATE</code>としてバインド(BTD接続文字列)</p>
<p>新規の「<code>TIMESTAMP</code>を<code>DATE</code>としてバインド」接続オプションが追加されました。これによりODBCドライバの<code>SQL_TIMESTAMP</code>データ型を、Oracleの<code>TIMESTAMP</code>データ型ではなく<code>DATE</code>データ型でバインドできます(これはデフォルトです)。</p>
</li>
<li>
<p><code>MONTHNAME (exp)</code>関数</p>
<p>日付式で表される月の名前を返す<code>MONTHNAME (exp)</code>関数のサポートが追加されました。たとえば、「April」などです。</p>
</li>
<li>
<p><code>DAYNAME (exp)</code>関数</p>
<p>日付式で表される日の名前を返す<code>DAYNAME (exp)</code>関数のサポートが追加されました。たとえば、「Tuesday」などです。</p>
</li>
<li>
<p>インスタント・クライアントの構成</p>
<p>インスタント・クライアント・モードの構成がサポートされるようになりました。</p>
</li>
</ul>
<a id="BABCCDCJ" name="BABCCDCJ"></a><a id="ADFNS1127" name="ADFNS1127"></a>
<p class="subhead2">リリース10.1.0.2.0の変更点</p>
<p>Oracle ODBC Driverリリース10.1.0.2.0で変更された機能、また将来廃止される可能性のある機能は次のとおりです。</p>
<ul>
<li>
<p>Microsoft Transaction Serverの無効化</p>
<p>Microsoft Transaction Server (MTS)を無効にするデフォルト設定が、<code>FALSE</code>から<code>TRUE</code>に変更されました。MTSのサポートは、デフォルトで無効になっています。</p>
</li>
<li>
<p>浮動小数点のデータ型</p>
<p>Oracleのデータ型である<code>BINARY_FLOAT</code>および<code>BINARY_DOUBLE</code>は、ODBCデータ型の<code>SQL_REAL</code>および<code>SQL_DOUBLE</code>にそれぞれマップされるように変更されました。</p>
</li>
<li>
<p>SQLGetDataの拡張(GDE接続文字列)</p>
<p>このリリースでは、<code>SQLGetData</code>の拡張接続は廃止されました。このオプションの機能は常に使用できます。</p>
</li>
<li>
<p>LONG列の強制取り出し(FRL接続文字列)</p>
<p>このリリースでは、「LONG列強制取り出し」接続オプションは廃止されました。このオプションの機能は常に使用できます。</p>
</li>
<li>
<p>「翻訳オプション」構成タブ</p>
<p>このリリースでは、「Oracle ODBCドライバ構成」ダイアログ・ボックスにあった「翻訳オプション」タブが削除されました。</p>
</li>
<li>
<p>リリース・ノート</p>
<p>リリース・ノートのファイル名が、<code>ODBCRelnotes.wri</code>から<code>ODBCRelnotesUS.htm</code>に変更されました。</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="BABBDJAA" name="BABBDJAA"></a><a id="ADFNS1128" name="ADFNS1128"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">サポートされていない機能</h4>
<p>Oracle ODBC Driverは、ODBC 3.0の次にあげる機能はサポートしていません。</p>
<ul>
<li>
<p>期間データ型</p>
</li>
<li>
<p><code>SQL_C_UBIGINT</code>および<code>SQL_C_SBIGINT</code> Cデータ型識別子</p>
</li>
<li>
<p>共有接続</p>
</li>
<li>
<p>共有環境</p>
</li>
<li>
<p><code>SQLSetConnectAttr</code>の<code>SQL_LOGIN_TIMEOUT</code>属性</p>
</li>
</ul>
<div class="tblformal"><a id="ADFNS1129" name="ADFNS1129"></a><a id="sthref3" name="sthref3"></a><a id="BABDEGAI" name="BABDEGAI"></a>
<p class="titleintable">表1-1 Oracle ODBC DriverでサポートされていないSQL関数</p>
<table border="1" cellpadding="3" cellspacing="0" class="Formal" dir="ltr" frame="hsides" rules="groups" summary="表では、Oracle ODBC Driverでサポートされていない関数を示しています。関数グループ名ごとに3つの機能列があります(文字列関数、数値関数、および日付/時刻/間隔関数)。" title="Oracle ODBC DriverでサポートされていないSQL関数" width="100%">
<col width="27%" />
<col width="27%" />
<col width="1*" />
<thead>
<tr align="left" valign="top">
<th id="r1c1-t2" align="left" valign="bottom">文字列関数</th>
<th id="r1c2-t2" align="left" valign="bottom">数値関数</th>
<th id="r1c3-t2" align="left" valign="bottom">日付/時刻関数</th>
</tr>
</thead>
<tbody>
<tr align="left" valign="top">
<td id="r2c1-t2" headers="r1c1-t2" align="left">
<p><code>BIT_LENGTH</code></p>
</td>
<td headers="r2c1-t2 r1c2-t2" align="left">
<p><code>ACOS</code></p>
</td>
<td headers="r2c1-t2 r1c3-t2" align="left">
<p><code>CURRENT_DATE</code></p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r3c1-t2" headers="r1c1-t2" align="left">
<p><code>CHAR_LENGTH</code></p>
</td>
<td headers="r3c1-t2 r1c2-t2" align="left">
<p><code>ASIN</code></p>
</td>
<td headers="r3c1-t2 r1c3-t2" align="left">
<p><code>CURRENT_TIME</code></p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r4c1-t2" headers="r1c1-t2" align="left">
<p><code>CHARACTER_LENGTH</code></p>
</td>
<td headers="r4c1-t2 r1c2-t2" align="left">
<p><code>ATAN</code></p>
</td>
<td headers="r4c1-t2 r1c3-t2" align="left">
<p><code>CURRENT_TIMESTAMP</code></p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r5c1-t2" headers="r1c1-t2" align="left">
<p><code>DIFFERENCE</code></p>
</td>
<td headers="r5c1-t2 r1c2-t2" align="left">
<p><code>ATAN2</code></p>
</td>
<td headers="r5c1-t2 r1c3-t2" align="left">
<p><code>EXTRACT</code></p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r6c1-t2" headers="r1c1-t2" align="left">
<p><code>OCTET_LENGTH</code></p>
</td>
<td headers="r6c1-t2 r1c2-t2" align="left">
<p><code>COT</code></p>
</td>
<td headers="r6c1-t2 r1c3-t2" align="left">
<p><code>TIMESTAMPDIFF</code></p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r7c1-t2" headers="r1c1-t2" align="left">
<p><code>POSITION</code></p>
</td>
<td headers="r7c1-t2 r1c2-t2" align="left">
<p><code>DEGREES</code></p>
</td>
<td headers="r7c1-t2 r1c3-t2" align="left"><br /></td>
</tr>
<tr align="left" valign="top">
<td id="r8c1-t2" headers="r1c1-t2" align="left"><br /></td>
<td headers="r8c1-t2 r1c2-t2" align="left">
<p><code>RADIANS</code></p>
</td>
<td headers="r8c1-t2 r1c3-t2" align="left"><br /></td>
</tr>
<tr align="left" valign="top">
<td id="r9c1-t2" headers="r1c1-t2" align="left"><br /></td>
<td headers="r9c1-t2 r1c2-t2" align="left">
<p><code>RAND</code></p>
</td>
<td headers="r9c1-t2 r1c3-t2" align="left"><br /></td>
</tr>
<tr align="left" valign="top">
<td id="r10c1-t2" headers="r1c1-t2" align="left"><br /></td>
<td headers="r10c1-t2 r1c2-t2" align="left">
<p><code>ROUND</code></p>
</td>
<td headers="r10c1-t2 r1c3-t2" align="left"><br /></td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect3" -->
<a id="BABHEGHC" name="BABHEGHC"></a><a id="ADFNS1130" name="ADFNS1130"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">インストールによって作成されるファイル</h4>
<div class="tblformal"><a id="ADFNS1131" name="ADFNS1131"></a><a id="sthref4" name="sthref4"></a><a id="BABFJJBD" name="BABFJJBD"></a>
<p class="titleintable">表1-2 Oracle ODBC Driverキットでインストールされるファイル</p>
<table border="1" cellpadding="3" cellspacing="0" class="Formal" dir="ltr" frame="hsides" rules="groups" summary="この表では、UNIXおよびWindowsプラットフォーム用のOracle ODBC Driverキットによってインストールされるファイルと、各ファイルの機能の簡単な説明を示しています。" title="Oracle ODBC Driverキットでインストールされるファイル" width="100%">
<col width="32%" />
<col width="32%" />
<col width="1*" />
<thead>
<tr align="left" valign="top">
<th id="r1c1-t3" align="left" valign="bottom">説明</th>
<th id="r1c2-t3" align="left" valign="bottom">Windowsインストールのファイル名</th>
<th id="r1c3-t3" align="left" valign="bottom">UNIXインストールのファイル名</th>
</tr>
</thead>
<tbody>
<tr align="left" valign="top">
<td id="r2c1-t3" headers="r1c1-t3" align="left">
<p>Oracle ODBCデータベース・アクセスDLL</p>
</td>
<td headers="r2c1-t3 r1c2-t3" align="left">
<p><code>sqora32.dll</code></p>
</td>
<td headers="r2c1-t3 r1c3-t3" align="left">
<p>libsqora.so.12.1</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r3c1-t3" headers="r1c1-t3" align="left">
<p>Oracle ODBC Driver設定DLL</p>
</td>
<td headers="r3c1-t3 r1c2-t3" align="left">
<p><code>sqoras32.dll</code></p>
</td>
<td headers="r3c1-t3 r1c3-t3" align="left">
<p>なし</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r4c1-t3" headers="r1c1-t3" align="left">
<p>Oracle ODBCリソースDLL</p>
</td>
<td headers="r4c1-t3 r1c2-t3" align="left">
<p><code>sqresus.dll</code></p>
</td>
<td headers="r4c1-t3 r1c3-t3" align="left">
<p>なし</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r5c1-t3" headers="r1c1-t3" align="left">
<p>日本語用のOracle ODBCリソースDLL</p>
</td>
<td headers="r5c1-t3 r1c2-t3" align="left">
<p><code>sqresja.dll</code></p>
</td>
<td headers="r5c1-t3 r1c3-t3" align="left">
<p>なし</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r6c1-t3" headers="r1c1-t3" align="left">
<p>Oracle ODBC Driverメッセージ・ファイル</p>
</td>
<td headers="r6c1-t3 r1c2-t3" align="left">
<p><code>oraodbcus.msb</code></p>
</td>
<td headers="r6c1-t3 r1c3-t3" align="left">
<p><code>oraodbcus.msb</code></p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r7c1-t3" headers="r1c1-t3" align="left">
<p>日本語用のOracle ODBC Driverメッセージ・ファイル</p>
</td>
<td headers="r7c1-t3 r1c2-t3" align="left">
<p><code>oraodbcja.msb</code></p>
</td>
<td headers="r7c1-t3 r1c3-t3" align="left">
<p><code>oraodbcja.msb</code></p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r8c1-t3" headers="r1c1-t3" align="left">
<p>Oracle ODBC Driverリリース・ノート</p>
</td>
<td headers="r8c1-t3 r1c2-t3" align="left">
<p>Oracle Databaseリリース12.1ドキュメント・ライブラリの<em>Oracle ODBC Driverリリース・ノート</em></p>
</td>
<td headers="r8c1-t3 r1c3-t3" align="left">
<p>Oracle Databaseリリース12.1ドキュメント・ライブラリの<em>Oracle ODBC Driverリリース・ノート</em></p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r10c1-t3" headers="r1c1-t3" align="left">
<p>Oracle ODBC Driver Instant Clientリリース・ノート</p>
</td>
<td headers="r10c1-t3 r1c2-t3" align="left">
<p><code>ODBC_IC_Readme_Win.html</code></p>
</td>
<td headers="r10c1-t3 r1c3-t3" align="left">
<p><code>ODBC_IC_Readme_Unix.html</code></p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r11c1-t3" headers="r1c1-t3" align="left">
<p>Oracle ODBC Driverヘルプ・ファイル</p>
</td>
<td headers="r11c1-t3 r1c2-t3" align="left">
<p><code>sqora.chm</code></p>
</td>
<td headers="r11c1-t3 r1c3-t3" align="left">
<p><code>sqora.chm</code></p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r12c1-t3" headers="r1c1-t3" align="left">
<p>日本語用のOracle ODBC Driverヘルプ・ファイル</p>
</td>
<td headers="r12c1-t3 r1c2-t3" align="left">
<p><code>sqora.chm</code></p>
</td>
<td headers="r12c1-t3 r1c3-t3" align="left">
<p><code>sqora.chm</code></p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r13c1-t3" headers="r1c1-t3" align="left">
<p>Oracle ODBC Driver Instant Clientインストール・スクリプト</p>
</td>
<td headers="r13c1-t3 r1c2-t3" align="left">
<p><code>odbc_install.exe</code></p>
</td>
<td headers="r13c1-t3 r1c3-t3" align="left">
<p><code>odbc_update_ini.sh</code></p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r14c1-t3" headers="r1c1-t3" align="left">
<p>Oracle ODBC Driver Instant Clientアンインストール・スクリプト</p>
</td>
<td headers="r14c1-t3 r1c2-t3" align="left">
<p><code>odbc_uninstall.exe</code></p>
</td>
<td headers="r14c1-t3 r1c3-t3" align="left">
<p>なし</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<a id="ADFNS1132" name="ADFNS1132"></a>
<p class="subhead2">Microsoftドライバ・マネージャおよびAdministratorファイル</p>
<p>Microsoft ODBC 3.52コンポーネントとともにインストールされるファイルのリストは、Microsoft ODBC 3.52 Software Development Kit and Programmer's Referenceを参照してください。</p>
<p>Microsoft ODBCコンポーネントは、Microsoft Data Access Component (MDAC)キットに含まれています。WindowsのOracle ODBC Driverは、MDACバージョン2.8を使用してテストされています。これは、<code><a href="http://www.microsoft.com/download/en/search.aspx?q=ODBC+MDAC">http://www.microsoft.com/download/en/search.aspx?q=ODBC+MDAC</a></code>からダウンロードできます。</p>
<a id="ADFNS1133" name="ADFNS1133"></a>
<p class="subhead2">unixODBCドライバ・マネージャおよびAdministratorファイル</p>
<p>unixODBCドライバ・マネージャとともにインストールされるファイルのリストは、unixODBCのREADMEファイルおよびINSTALLファイルを参照してください。</p>
<p>unixODBCドライバ・マネージャは、<code><a href="http://www.unixodbc.org/download.html">http://www.unixodbc.org/download.html</a></code>からダウンロードできます。</p>
</div>
<!-- class="sect3" -->
<a id="BABECBDH" name="BABECBDH"></a><a id="ADFNS1134" name="ADFNS1134"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">ドライバの準拠レベル</h4>
<p>ODBCは、次の2つの分野でドライバの<a href="#BABJACEF">準拠レベル</a>を定義しています。</p>
<ul>
<li>
<p>ODBC Application Program Interface (<a href="#BABECBJJ">API</a>)</p>
</li>
<li>
<p>ODBC SQL-99の構文</p>
</li>
</ul>
<p>Oracle ODBC Driverは、APIのすべてのコア機能と、レベル1およびレベル2機能セットの一部をサポートしています。詳細は、<a href="#BABBCJCB">「API準拠」</a>を参照してください。</p>
<p>Oracle ODBC DriverはSQL-92のエントリ・レベル仕様のスーパーセットであるSQL-99のコア仕様と広く互換性があります。SQL-99でサポートされる機能のリストを取得するには、アプリケーションにおいて適切な情報型を指定してSQLGetInfoをコールしてください。</p>
</div>
<!-- class="sect3" -->
<a id="BABCICCF" name="BABCICCF"></a><a id="ADFNS1135" name="ADFNS1135"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">既知の制限事項</h4>
<p>次の事項は、Oracle ODBC Driverではサポートされていません。</p>
<ul>
<li>
<p>ODBC ASYNCインタフェース</p>
</li>
<li>
<p>アプリケーションでの[Ctrl]+[C]を使用した取消し</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABGJJAF" name="BABGJJAF"></a><a id="ADFNS1136" name="ADFNS1136"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">構成タスク</h3>
<ul>
<li>
<p><a href="#BABDFDJB">Oracle Net Servicesの構成</a></p>
</li>
<li>
<p><a href="#BABBCBHH">データソースの構成</a></p>
</li>
<li>
<p><a href="#BABEFEHG">「Oracle ODBCドライバ構成」ダイアログ・ボックス</a></p>
</li>
</ul>
<a id="BABDFDJB" name="BABDFDJB"></a><a id="ADFNS1137" name="ADFNS1137"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Oracle Net Servicesの構成</h4>
<p><a href="#BABBCBHH">データソースを構成する</a>前に、ネットワーク・データベース・サービスを構成して各TNSサービス名のエントリを構成する必要があります。これを行うには、<a href="#BABFGCHB">Oracle Net Configuration Assistant (NETCA)</a>を使用します。</p>
<p>NETCAを使用してtnsnames.oraファイルに各TNSサービス名のエントリを作成できます。Oracle Net Servicesのインストール時に、NETCAもインストールされます。</p>
</div>
<!-- class="sect3" -->
<a id="BABBCBHH" name="BABBCBHH"></a><a id="ADFNS1138" name="ADFNS1138"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">データソースの構成</h4>
<div align="center">
<div class="inftblnote"><br />
<table border="1" cellpadding="3" cellspacing="0" class="Note oac_no_warn" frame="hsides" rules="groups" summary="" width="80%">
<tbody>
<tr>
<td align="left">
<p class="notep1">注意:</p>
次の構成手順はWindowsユーザー用です。UNIXユーザーは、<code>odbc_update_ini.sh</code>ファイルを使用してデータソース名(DSN)を作成する必要があります。</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblnote" --></div>
<p>Oracle ODBC Driverをインストールして<a href="#BABDFDJB">Oracle Net Servicesを構成</a>した後、Oracle ODBC Driverを使用する前に、データソースを構成する必要があります。</p>
<p>アプリケーションとデータソース間で通信を行うには、構成情報が設定されている必要があります。Oracle ODBC Driverは、この構成情報からアクセス対象の情報を取得します。</p>
<p>データソースは、アクセス対象のデータと、それに対応付けられたオペレーティング・システム、データベース管理システムおよびデータベース管理システムにアクセスするためのネットワーク・プラットフォームで構成されます。Oracle ODBC Driverが発行する要求のデータソースはOracleデータベースであり、このデータソースはOracle Net Servicesによるトランスポートをサポートしています。</p>
<a id="ADFNS1139" name="ADFNS1139"></a>
<p class="subhead2">Oracleデータソースを構成または追加するには</p>
<p>Oracle ODBC Driverをインストールしたら、ODBCデータソース管理者を使用して、各OracleデータベースにOracleデータソースを構成または追加します。Oracle ODBC Driverは、データソースを追加する際にユーザーが入力する情報を使用してデータにアクセスします。次の手順を実行します。</p>
<ol>
<li>
<p>「スタート」メニューから「プログラム」→「管理ツール」→「データ ソース (ODBC)」を選択します。インストールされているドライバのリストが表示されます。</p>
</li>
<li>
<p>新規データ ソースの作成ウィンドウで<span class="bold">「追加」</span>をクリックし、インストール済ドライバのリストで「Oracle ODBC Driver」を選択します。</p>
</li>
<li>
<p><span class="bold">「終了」</span>をクリックします。<a href="#BABEFEHG">「Oracle ODBCドライバ構成」ダイアログ・ボックス</a>が表示されます。データソース名とTNSサービス名は必ず入力する必要があります。このダイアログ・ボックスでその他の必要な情報を入力することも、フィールドを空白のままにして、アプリケーションを実行するときに情報を指定することもできます。</p>
</li>
<li>
<p>データを入力したら、<span class="bold">「OK」</span>をクリックするか<span class="bold">[Enter]</span>を押します。</p>
</li>
</ol>
<p>データソースはいつでも変更または削除できます。次の項では、データソースの追加、変更または削除方法を説明します。</p>
<a id="ADFNS1140" name="ADFNS1140"></a>
<p class="subhead2">Oracleデータソースを変更するには</p>
<ol>
<li>
<p>「スタート」メニューから<span class="bold">「プログラム」→「管理ツール」→「データ ソース(ODBC)」</span>を選択します。</p>
</li>
<li>
<p>「ODBC データ ソース アドミニストレータ」ダイアログ・ボックスで、データソースのリストからデータソースを選択し、<span class="bold">「構成」</span>をクリックします。「Oracle ODBCドライバ構成」ダイアログ・ボックスが表示されます。</p>
</li>
<li>
<p><a href="#BABEFEHG">「Oracle ODBCドライバ構成」ダイアログ・ボックス</a>で、必要に応じてオプション値を変更し、<span class="bold">「OK」</span>をクリックします。</p>
</li>
</ol>
<a id="ADFNS1141" name="ADFNS1141"></a>
<p class="subhead2">Oracleデータソースを削除するには</p>
<ol>
<li>
<p>「スタート」メニューから<span class="bold">「プログラム」→「管理ツール」→「データ ソース(ODBC)」</span>を選択します。</p>
</li>
<li>
<p>「ODBC データ ソース アドミニストレータ」ダイアログ・ボックスで、データソースのリストから削除するデータソースを選択します。</p>
</li>
<li>
<p><span class="bold">「削除」</span>、<span class="bold">「はい」</span>の順にクリックして、削除を確定します。</p>
</li>
</ol>
<a id="ADFNS1142" name="ADFNS1142"></a>
<p class="subhead2">関連トピック</p>
<p><a href="#BABDCHIG">Oracleデータソースへの接続</a></p>
<p><a href="#BABCGCCI">Oracle ODBC Driverの最初の使用</a></p>
</div>
<!-- class="sect3" -->
<a id="BABEFEHG" name="BABEFEHG"></a><a id="ADFNS1143" name="ADFNS1143"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">「Oracle ODBCドライバ構成」ダイアログ・ボックス</h4>
<div align="center">
<div class="inftblnote"><br />
<table border="1" cellpadding="3" cellspacing="0" class="Note oac_no_warn" frame="hsides" rules="groups" summary="" width="80%">
<tbody>
<tr>
<td align="left">
<p class="notep1">注意:</p>
「Oracle ODBCドライバ構成」ダイアログ・ボックスを使用できるのは、Microsoft Windowsユーザーのみです。</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblnote" --></div>
<div class="figure"><a id="BABHIHGI" name="BABHIHGI"></a><a id="ADFNS1144" name="ADFNS1144"></a>
<p class="titleinfigure">図1-3 「Oracle ODBCドライバ構成」ダイアログ・ボックス</p>
<img alt="図1-3の説明が続きます" longdesc="img_text/setup_app.htm" src="img/setup_app.gif" /><br /> <a href="img_text/setup_app.htm" id="sthref5" name="sthref5">「図1-3 「Oracle ODBCドライバ構成」ダイアログ・ボックス」の説明</a><br /> <br /></div>
<!-- class="figure" -->
<p>次のリストは、前図に示した「Oracle ODBCドライバ構成」ダイアログ・ボックスにあるメイン設定オプションおよびフィールドの説明です。ダイアログ・ボックスの下半分にあるタブは次以降のトピックで説明します。</p>
<ul>
<li>
<p><span class="bold">データソース名</span> - ODBCでデータソースを識別する名前。たとえば、「odbc-pc」です。データソース名は入力する必要があります。</p>
</li>
<li>
<p><span class="bold">説明</span> - データソースに含まれているデータについての説明やコメント。たとえば、「全従業員の入社日、給与履歴、現行評価」などとします。「説明」フィールドはオプションです。</p>
</li>
<li>
<p><span class="bold">TNSサービス名</span> - ODBCドライバがデータを取得するOracleデータベースの位置。これは、<a href="#BABDFDJB">Oracle Net Servicesを構成</a>したときに、<a href="#BABFGCHB">Oracle Net Configuration Assistant (NETCA)</a>を使用して入力したものと同じ名前です。詳細は、NETCAのマニュアルおよび<a href="#BABCGCCI">「Oracle ODBCドライバの最初の使用」</a>を参照してください。TNSサービス名は、使用可能なTNS名のプルダウン・リストから選択できます。たとえば、「ODBC-PC」を選択します。TNSサービス名を入力する必要があります。</p>
</li>
<li>
<p><span class="bold">ユーザーID</span> - データにアクセスするために使用するサーバー上のアカウントのユーザー名です。たとえば、「scott」です。「ユーザーID」フィールドはオプションです。</p>
</li>
</ul>
<p>「データソース名」と「TNSサービス名」は必ず入力する必要があります。このダイアログ・ボックスでその他の情報を入力することも、フィールドを空白のままにして、アプリケーションを実行するときに情報を指定することもできます。</p>
<p>前述のメイン設定オプションの他に、「接続テスト」ボタンがあります。このボタンは、データソース名定義で指定されたデータベースに接続することによってODBC環境が適切に構成されているかを確認します。「接続テスト」ボタンを押し、ユーザー名およびパスワードを入力してください。</p>
<p>「Oracle ODBCドライバ構成」ダイアログ・ボックスの下半分にあるオプション・タブの説明は、次のリンクのいずれかをクリックします。</p>
<p><a href="#BABEJFGH">アプリケーション・オプション</a></p>
<p><a href="#BABFJIJI">Oracleオプション</a></p>
<p><a href="#BABIFAAB">Workaroundsオプション</a></p>
<p><a href="#BABDIDEF">SQL Server移行オプション</a></p>
<a id="BABEJFGH" name="BABEJFGH"></a><a id="ADFNS1145" name="ADFNS1145"></a>
<p class="subhead2">アプリケーション・オプション</p>
<div class="figure"><a id="BABIDJBI" name="BABIDJBI"></a><a id="ADFNS1146" name="ADFNS1146"></a>
<p class="titleinfigure">図1-4 「Oracle ODBCドライバ構成」ダイアログ・ボックスの「アプリケーション」オプション・タブ</p>
<img alt="図1-4の説明が続きます" longdesc="img_text/setup_app.htm" src="img/setup_app.gif" /><br /> <a href="img_text/setup_app.htm" id="sthref6" name="sthref6">「図1-4 「Oracle ODBCドライバ構成」ダイアログ・ボックスの「アプリケーション」オプション・タブ」の説明</a><br /> <br /></div>
<!-- class="figure" -->
<p>次のリストは、前図で示した「アプリケーション」タブにあるフィールドの説明です。</p>
<ul>
<li>
<p><span class="bold">結果セットを有効化</span> - Oracle結果セットの処理を有効にします。結果セットがアプリケーションに必要ない場合、結果セットのサポートを無効にできます。パッケージからの結果セットを含んでいないプロシージャ・コールは、少々パフォーマンスが低下します。デフォルトでは、結果セットは有効です。</p>
</li>
<li>
<p><span class="bold">問合せタイムアウトを有効化</span> - SQL問合せで、タイムアウトを有効にします。デフォルトでは、Oracle ODBC DriverはSQLSetStmtAttr関数用に<code>SQL_ATTR_QUERY_TIMEOUT</code>属性をサポートします。このボックスが選択されていない場合、Oracle ODBC Driverは、「不可」メッセージを返します。デフォルトでは、問合せタイムアウトは有効です。</p>
</li>
<li>
<p><span class="bold">読取専用接続</span> - 読取り専用アクセスを指定するには、このボックスを選択します。デフォルトは、書込み可能な接続です。</p>
</li>
<li>
<p><span class="bold">カーソル・クローズを有効化</span> - カーソル・クローズを有効にします。デフォルトでは、カーソル・クローズは無効(フィールドが空)になっています。これは、不必要なパフォーマンス低下の原因となるためこの動作が望ましくない場合に、カーソルのクローズをコールしてもOCIカーソルのクローズが強制されないことを意味します。カーソルのクローズをコールしたときにOCIカーソルを強制的にクローズすることが望ましい場合は、カーソル・クローズを有効にする必要があります。</p>
</li>
</ul>
<div align="center">
<div class="inftblnote"><br />
<table border="1" cellpadding="3" cellspacing="0" class="Note oac_no_warn" frame="hsides" rules="groups" summary="" width="80%">
<tbody>
<tr>
<td align="left">
<p class="notep1">注意:</p>
カーソルがクローズされるたびに、パフォーマンスに影響があります。</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblnote" --></div>
<ul>
<li>
<p><span class="bold">スレッド・セーフティを有効化</span> - データソースについてスレッド・セーフティを無効にすることもできます。スレッド・セーフティが不要な場合は、このオプションを指定しなければスレッド・セーフティのオーバーヘッドをなくすことができます。デフォルトではスレッド・セーフティは有効です。</p>
</li>
<li>
<p><span class="bold">バッチ自動コミット・モード</span> - デフォルトでは、すべての文が成功した場合、コミットが実行されます。</p>
</li>
<li>
<p><span class="bold">数値の設定</span> - 文字列としてバインドされた数値データの受け渡しで、どの数値設定を使用して小数点文字や3桁セパレータを決定するかを指定します。このオプションでは、Oracle NLSの設定(デフォルトの設定)、Microsoftのデフォルトの地域設定(Oracle OLE DBドライバの動作と合わせ相互運用性を向上)、US数値設定(英語環境以外でMS AccessまたはDAO (Database Access Object)を使用する際に必要)の選択ができます。</p>
</li>
</ul>
<p>メイン構成設定オプションの説明は、<a href="#BABEFEHG">「「Oracle ODBCドライバ構成」ダイアログ・ボックス」</a>のトピックにあります。</p>
<a id="BABFJIJI" name="BABFJIJI"></a><a id="ADFNS1147" name="ADFNS1147"></a>
<p class="subhead2">Oracleオプション</p>
<div class="figure"><a id="BABGBICJ" name="BABGBICJ"></a><a id="ADFNS1148" name="ADFNS1148"></a>
<p class="titleinfigure">図1-5 「Oracle ODBCドライバ構成」ダイアログ・ボックスの「Oracle」オプション・タブ</p>
<img alt="図1-5の説明が続きます" longdesc="img_text/setup_ora.htm" src="img/setup_ora.gif" /><br /> <a href="img_text/setup_ora.htm" id="sthref7" name="sthref7">「図1-5 「Oracle ODBCドライバ構成」ダイアログ・ボックスの「Oracle」オプション・タブ」の説明</a><br /> <br /></div>
<!-- class="figure" -->
<p>次のリストは、前図で示した「Oracle」タブにあるフィールドの説明です。</p>
<ul>
<li>
<p><span class="bold">フェッチ・バッファ・サイズ</span> - 単一の問合せでアプリケーション・プログラムがリクエストする行数に関係なく、ODBCドライバがOracleデータベースから一度にプリフェッチするデータの行数を決定するために使用されるメモリー量。ただし、プリフェッチされる行数は、単一の問合せで指定された列の幅と数に依存します。通常一度に20行未満をフェッチするアプリケーションでは、低速なネットワーク接続上で動作する場合や非常に負荷の高いサーバーにアクセスする場合には特に、レスポンス時間が向上します。これを大きく設定しすぎると、実際にはレスポンス時間が悪化したり、メモリーを大量に消費したりすることがあります。</p>
</li>
</ul>
<div align="center">
<div class="inftblnote"><br />
<table border="1" cellpadding="3" cellspacing="0" class="Note oac_no_warn" frame="hsides" rules="groups" summary="" width="80%">
<tbody>
<tr>
<td align="left">
<p class="notep1">注意:</p>
<code>LONG</code>およびLOBデータ型がある場合、ODBCドライバのプリフェッチ行数は、フェッチ・バッファ・サイズに依存しません。<code>LONG</code>およびLOBデータ型では、パフォーマンスの改善が見込めず、過度のメモリー消費を引き起こす可能性があります。ODBCドライバは、<code>LONG</code>およびLOBデータ型が含まれる場合、フェッチ・バッファ・サイズを無視し、プリフェッチ行数を使用します。</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblnote" --></div>
<ul>
<li>
<p><span class="bold">LOBを有効化</span> - Oracle LOBの書込みを可能にします。アプリケーションにOracle LOBの書込みが不要であれば、LOBのサポートは無効にできます。LOBを有効にすると、INSERT文とUPDATE文の処理時にわずかながらパフォーマンスが低下します。LOBの書込みはデフォルトで有効ですが、LOBデータ型をサポートしないOracleデータベースでは無効になります。</p>
</li>
<li>
<p><span class="bold">ステートメントのキャッシングを有効化</span> - 文キャッシュ機能を有効にします。これにより、ユーザーが問合せおよび関連パラメータの同じテキストを複数回解析する必要がある場合に、問合せの解析パフォーマンスが向上します。デフォルトでは無効になります。</p>
</li>
<li>
<p><span class="bold">キャッシュバッファサイズ</span> - 文のキャッシュには、サービス・コンテキスト(<code>OCI_ATTR_STMTCACHESIZE</code>)の属性を使用して変更可能な最大サイズ(文の数)があります。デフォルトのキャッシュ・バッファ・サイズは20で、文キャッシングのオプションが有効化されている場合にのみ使用されます。キャッシュ・バッファ・サイズを0に設定すると、文のキャッシング機能は無効になります。</p>
</li>
<li>
<p><span class="bold">最大トークン・サイズ</span> - トークン・サイズを4 KB (4096バイト)から開始する最も近い1 KB (1024バイト)の倍数に設定します。デフォルト・サイズは8 KB (8192バイト)です。設定できる最大値は128 KB (131068バイト)です。</p>
</li>
<li>
<p><span class="bold">ORAエラーを変換</span> - SQL翻訳フレームワーク機能を使用している移行済のサード・パーティODBCアプリケーションでは、サーバーから返されるエラーがネイティブ・データベース形式を取ると予想されます。このオプションを有効にすると、SQL翻訳プロファイルに登録されているエラー翻訳に基づいたネイティブ・エラーを受け取ることができます。</p>
</li>
<li>
<p><span class="bold">空の文字列を変換</span> - Oracle Databaseに移行されたサード・パーティのODBCアプリケーションでは、空の文字列データを処理する必要があります(Oracle Databaseでは表の列にある空の文字列データが処理されません)。このオプションを有効にすると、アプリケーションで空の文字列データの挿入または取得ができるようになります。</p>
<div align="center">
<div class="inftblnote"><br />
<table border="1" cellpadding="3" cellspacing="0" class="Note oac_no_warn" frame="hsides" rules="groups" summary="" width="80%">
<tbody>
<tr>
<td align="left">
<p class="notep1">注意:</p>
この機能は、リリース12.1に実装されていません。</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblnote" --></div>
</li>
</ul>
<p>「Oracle」タブの「フェイルオーバー」領域には次のフィールドがあります。</p>
<ul>
<li>
<p><span class="bold">フェイルオーバーを有効化</span> - Oracle Fail SafeとOracle Parallel Serverのフェイルオーバーの再試行を有効にします。このオプションは、Oracle Fail SafeとOracle Parallel Serverのフェイルオーバー機能に対する拡張です。このオプションで追加フェイルオーバー再試行が構成可能になります。デフォルトは有効です。</p>
</li>
<li>
<p><span class="bold">再試行</span> - 接続のフェイルオーバーを試みる回数。デフォルトは10回です。</p>
</li>
<li>
<p><span class="bold">遅延</span> - フェイルオーバーを試みる間隔の秒数。デフォルトは10秒です。</p>
</li>
</ul>
<div align="center">
<div class="inftblnote"><br />
<table border="1" cellpadding="3" cellspacing="0" class="Note oac_no_warn" frame="hsides" rules="groups" summary="" width="80%">
<tbody>
<tr>
<td align="left">
<p class="notep1">注意:</p>
Oracle Fail SafeとOracle Parallel Serverの設定や使用方法については、それぞれの製品のドキュメントを参照してください。</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblnote" --></div>
<p>メイン構成設定オプションの説明は、<a href="#BABEFEHG">「「Oracle ODBCドライバ構成」ダイアログ・ボックス」</a>のトピックにあります。</p>
<a id="BABIFAAB" name="BABIFAAB"></a><a id="ADFNS1149" name="ADFNS1149"></a>
<p class="subhead2">Workaroundsオプション</p>
<div class="figure"><a id="BABIGDJC" name="BABIGDJC"></a><a id="ADFNS1150" name="ADFNS1150"></a>
<p class="titleinfigure">図1-6 「Oracle ODBCドライバ構成」ダイアログ・ボックスの「Workarounds」オプション・タブ</p>
<img alt="図1-6の説明が続きます" longdesc="img_text/setup_work.htm" src="img/setup_work.gif" /><br /> <a href="img_text/setup_work.htm" id="sthref8" name="sthref8">「図1-6 「Oracle ODBCドライバ構成」ダイアログ・ボックスの「Workarounds」オプション・タブ」の説明</a><br /> <br /></div>
<!-- class="figure" -->
<p>次のリストは、前図で示した「Workarounds」タブにあるフィールドの説明です。</p>
<ul>
<li>
<p><span class="bold">TIMESTAMPをDATEとしてバインド</span> - このボックスを選択すると、Oracle ODBC Driverにより、<code>SQL_TIMESTAMP</code>パラメータがOracleの<code>TIMESTAMP</code>型(デフォルト)ではなくOracle  <code>DATE</code>型で強制的にバインドされます。詳細は、<a href="#BABBAEEH">「データ型の実装」</a>を参照してください。</p>
</li>
<li>
<p><span class="bold">SQL_WCHAR強制サポート</span> - このボックスを選択すると、SQLDescribeCol、SQLColumnsおよびSQLProcedureColumnsにより、<code>SQL_CHAR</code>列には<code>SQL_WCHAR</code>のデータ型、<code>SQL_VARCHAR</code>列には<code>SQL_WVARCHAR</code>のデータ型、および<code>SQL_LONGVARCHAR</code>列には<code>SQL_WLONGVARCHAR</code>のデータ型がそれぞれ無条件で戻されるようになります。この機能により、これらのODBCコールの結果に依存するアプリケーション(たとえば、ADOアプリケーション)でのUnicodeのサポートが可能になります。デフォルトでは、このサポートは無効になっています。</p>
</li>
<li>
<p><span class="bold">MTS無効</span> - このボックスの選択を解除すると、Microsoft Transaction Server (MTS)サポートが有効になります。MTSのサポートは、デフォルトで無効になっています。</p>
</li>
<li>
<p><span class="bold">METADATA IDデフォルトにSQL_TRUEをセット</span> - このボックスを選択すると、<code>SQL_ATTR_METADATA_ID</code>接続と接続時の文属性のデフォルト値が<code>SQL_TRUE</code>に変更されます。通常では<code>SQL_ATTR_METADATA_ID</code>は<code>SQL_FALSE</code>がデフォルトです。接続後に明示的に属性値を変更するアプリケーションのODBCコールが、このオプションにより影響を受けることはなく、関数は問題なく終了します。デフォルトでは、このオプションは無効です。<a href="#BABHEGBH">「ODBC API関数の実装」</a>のトピックに、<code>SQL_ATTR_METADATA_ID</code>属性に関する追加情報があります。</p>
</li>
<li>
<p><span class="bold">LONG列データのサイズをプリフェッチ</span> - <code>LONG</code>または<code>LONG RAW</code>データをプリフェッチしてODBCアプリケーションのパフォーマンスを向上させるには、この値を設定します。この機能強化により、ユーザーが設定したプリフェッチ・サイズに応じてOracle ODBC Driverのパフォーマンスが最大10倍向上します。デフォルト値は0 (ゼロ)です。設定できる最大値は64KB (65536バイト)です。</p>
<p>プリフェッチ・サイズの値が65536より大きい値に設定されていても、フェッチされるデータは65536バイトのみです。データベースに65536バイトより大きい<code>LONG</code>または<code>LONG RAW</code>データがある場合は、単一行のフェッチが行われ、完全な<code>LONG</code>データがフェッチされるように、プリフェッチ・サイズを0 (デフォルト値)に設定する必要があります。ポーリング以外のモードでプリフェッチ・サイズより少ないバッファ・サイズを渡すと、データベースの<code>LONG</code>データ・サイズがバッファ・サイズより大きい場合には、データの切捨てエラーが発生します。</p>
</li>
<li>
<p><span class="bold">SQLDescribeParamを無効化</span> - SQLDescribeParam関数が有効な場合、すべてのパラメータに対して<code>SQL_VARCHAR</code>データ型が戻されます。SQL_WCHAR強制サポート関数も有効な場合は、すべてのパラメータに対して<code>SQL_WVARCHAR</code>データ型が戻されます。デフォルトでは、この関数は有効です。</p>
</li>
<li>
<p><span class="bold">NUMBERをFLOATとしてバインド</span> - このボックスを選択すると、Oracle ODBC Driverで、<code>FLOAT</code>データを含む<code>NUMBER</code>列がBinary Float (デフォルト)ではなくFloatとしてバインドされます。</p>
</li>
<li>
<p><span class="bold">RULEヒントを無効化</span> - このボックスの選択を解除すると、カタログ問合せで指定されているRULEヒントが有効になります。デフォルトでは、RULEヒントのオプションは無効です。</p>
</li>
<li>
<p><span class="bold">OCIDescribeAnyを使用</span> - このボックスを選択すると、アプリケーションが<code>REF CURSORS</code>を戻す小さなパッケージ・プロシージャを頻繁にコールする場合にドライバに<code>OCIDescribeAny()</code>の使用を強制することで、パフォーマンスが向上します。</p>
</li>
</ul>
<p>メイン構成設定オプションの説明は、<a href="#BABEFEHG">「「Oracle ODBCドライバ構成」ダイアログ・ボックス」</a>のトピックにあります。</p>
<a id="BABDIDEF" name="BABDIDEF"></a><a id="ADFNS1151" name="ADFNS1151"></a>
<p class="subhead2">SQL Server移行オプション</p>
<div class="figure"><a id="BABIIBJE" name="BABIIBJE"></a><a id="ADFNS1152" name="ADFNS1152"></a>
<p class="titleinfigure">図1-7 「Oracle ODBCドライバ構成」ダイアログ・ボックスのSQL Server移行オプション・タブ</p>
<img alt="図1-7の説明が続きます" longdesc="img_text/setup_ssmig.htm" src="img/setup_ssmig.gif" /><br /> <a href="img_text/setup_ssmig.htm" id="sthref9" name="sthref9">「図1-7 「Oracle ODBCドライバ構成」ダイアログ・ボックスのSQL Server移行オプション・タブ」の説明</a><br /> <br /></div>
<!-- class="figure" -->
<p>次のリストは、前図で示したSQL Server移行オプション・タブにあるフィールドの説明です。</p>
<ul>
<li>
<p><span class="bold">Enable EXEC Syntax</span> - SQL Server EXEC構文のサポートを有効にします。Oracleデータベース・サーバーによって処理される前に、EXEC文で指定されるプロシージャ(またはファンクション)コールは、対応するOracleプロシージャ(またはファンクション)コールに変換されます。デフォルトではこのオプションは無効になっています。</p>
</li>
<li>
<p><span class="bold">スキーマ</span> - 変換されたOracleプロシージャ(またはファンクション)は、ユーザーのデフォルト・スキーマに定義されます。しかし、同じSQL Serverデータベースからのすべてのプロシージャ(またはファンクション)を、データベース名をスキーマ名としてOracleスキーマに移行する場合、このフィールドは「データベース」に設定する必要があります。同じSQL Serverユーザーに所有されていたすべてのプロシージャ(またはファンクション)を同じOracleスキーマに定義する場合、このフィールドは「オーナー」に設定します。デフォルトでは、このフィールドは空欄になっています。</p>
</li>
</ul>
<p>メイン構成設定オプションの説明は、<a href="#BABEFEHG">「「Oracle ODBCドライバ構成」ダイアログ・ボックス」</a>のトピックにあります。</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABHABJB" name="BABHABJB"></a><a id="ADFNS1153" name="ADFNS1153"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">oraodbc.iniファイルの変更</h3>
<ul>
<li>
<p><a href="#BABEGGIB">ロック・タイムアウトの短縮</a></p>
</li>
</ul>
<a id="BABEGGIB" name="BABEGGIB"></a><a id="ADFNS1154" name="ADFNS1154"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">ロック・タイムアウトの短縮</h4>
<p>Oracleサーバーは、トランザクション間のロック競合が解消されるまで無期限に待機します。Oracle ODBC Driverの<code>oraodbc.ini</code>ファイルの<code>LockTimeOut</code>エントリを設定することで、Oracleサーバーがロックの解消を待機する時間を制限できます。<code>LockTimeOut</code>パラメータに入力する値は、Oracleサーバーがリクエストしたロックを取得できない場合にタイムアウトになるまでの秒数です。次の例では、Oracleサーバーは60秒後にタイムアウトになります。</p>
<pre xml:space="preserve" class="oac_no_warn">[Oracle ODBC Driver Common]<br />LockTimeOut=60<br /></pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABDBDJG" name="BABDBDJG"></a><a id="ADFNS1155" name="ADFNS1155"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">データソースへの接続</h3>
<ul>
<li>
<p><a href="#BABDCHIG">Oracleデータソースへの接続</a></p>
</li>
</ul>
<a id="BABDCHIG" name="BABDCHIG"></a><a id="ADFNS1156" name="ADFNS1156"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Oracleデータソースへの接続</h4>
<p>Oracle ODBC Driverでは、<a href="#BABFICBD">データソース</a>に接続するために、使用するコンピュータにOCIクライアント・ソフトウェアがインストールされていて、対応するリスナーがOracleサーバーで実行されていることが必要です。Oracle Net Services for Windowsは、ダイナミック・リンク・ライブラリ(DLL)に基づくアプリケーションです。Oracle Net Servicesの詳細は、Oracle Net Servicesのマニュアルを参照してください。</p>
<p>接続処理の一部として、アプリケーションがユーザーに情報を要求することがあります。アプリケーションからOracleデータソースについての情報を要求された場合は、次の手順を実行します。</p>
<ol>
<li>
<p>「TNSサービス名」ボックスで、TNSサービス名の名前を入力します。</p>
</li>
<li>
<p>「ユーザー名」ボックスに、Oracleデータベースにアクセスするために使用する名前を入力します。</p>
</li>
<li>
<p>「パスワード」ボックスに、Oracleデータベースにアクセスするために使用するパスワードを入力します。</p>
</li>
<li>
<p><span class="bold">「OK」</span>をクリックします。</p>
</li>
</ol>
<p>アプリケーションは、データソース内のデータにアクセスするためにはデータソースに接続する必要があります。データソースに接続するタイミングは、アプリケーションによって異なります。たとえば、アプリケーションがユーザーの要求時にのみデータソースに接続する場合もあれば、起動時に自動的に接続する場合もあります。アプリケーションがいつデータソースに接続するかは、そのアプリケーションのマニュアルを参照してください。</p>
<p>追加情報にアクセスするには、次のリンクのいずれかをクリックします。</p>
<a id="ADFNS1157" name="ADFNS1157"></a>
<p class="subhead2">全ユーザー向け関連項目</p>
<p><a href="#BABBCBHH">データソースの構成</a></p>
<a id="ADFNS1158" name="ADFNS1158"></a>
<p class="subhead2">プログラマ向け関連項目</p>
<p><a href="#BABIDEDG">SQLDriverConnectの実装</a></p>
<p><a href="#BABFHDGC">データソース構成オプション</a></p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABCHDJE" name="BABCHDJE"></a><a id="ADFNS1159" name="ADFNS1159"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">トラブルシューティング</h3>
<ul>
<li>
<p><a href="#BABCGCCI">Oracle ODBC Driverの最初の使用</a></p>
</li>
<li>
<p><a href="#BABGAIIC">期限切れパスワード</a></p>
</li>
</ul>
<a id="BABCGCCI" name="BABCGCCI"></a><a id="ADFNS1160" name="ADFNS1160"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Oracle ODBC Driverの最初の使用</h4>
<p>注意: この情報は、Microsoft Windowsユーザー用です。</p>
<p>Oracle ODBC Driverを使用して初めてデータベースまたは表にアタッチしようとするときに、次の問題が発生することがあります。</p>
<ul>
<li>
<p>Oracle ODBC Driverを正常に動作させるために、システム・パスに<code><span class="codeinlineitalic">OracleHome</span></code><code>/bin</code>を設定する必要がある</p>
<p>コマンド・プロンプトで<code>PATH</code>コマンドを使用して確認します。</p>
</li>
<li>
<p>マシンまたはサーバー・システムに必要なソフトウェアがない</p>
<br /> <span class="bold">問題:</span> Oracle ODBC Driverの処理が失敗する。<br /> <span class="bold">原因:</span> マシンにOCIソフトウェアがインストールされていないか、サーバー・システムにOracleデータベース・ソフトウェアがインストールされていない。<br /> <span class="bold">推奨処置: </span>クライアントマシンに必要なOCIソフトウェアをインストールするか、サーバー・システムにOracleデータベース・ソフトウェアをインストールします(必要な場合は両方)。</li>
<li>
<p>マシンに設定されているクライアント/サーバー接続が正しくない</p>
<br /> <span class="bold">問題:</span> マシンからサーバー・システムに接続できない。<br /> <span class="bold">原因:</span> 必要なトランスポート・ソフトウェアがインストールされていないか、正しく構成されていない。<br /> <span class="bold">推奨処置:</span> テストとして、たとえばTCP/IPを使用している場合、Oracleデータベースが存在するサーバーにマシンがpingできることを確認します。<code>\orant\bin</code>または<code>\Oracle\ora90\bin</code>ディレクトリにある<code>tnsping.exe</code>を使用すると、特定のデータベース・サービスへの接続を確認できます。次に例を示します。<br /> <code>C:/ORANT/BIN>tnsping database-service-name</code></li>
<li>
<p>TNSサービス名がOracle Net Configuration Assistant (NETCA)で入力された名前と一致しない</p>
<br /> <span class="bold">問題:</span> ユーザーがOracle ODBC Driverの設定を試行すると、TNSサービス名についてのエラー・メッセージが戻される。<br /> <span class="bold">原因:</span> TNSサービス名がNETCAで入力された名前と一致しない。<br /> <span class="bold">推奨処置:</span> Oracle ODBC Driverのセットアップ・ウィンドウのTNSサービス名を、NETCAのTNSサービス名と一致するように変更します。
<div align="center">
<div class="inftblnote"><br />
<table border="1" cellpadding="3" cellspacing="0" class="Note oac_no_warn" frame="hsides" rules="groups" summary="" width="80%">
<tbody>
<tr>
<td align="left">
<p class="notep1">注意:</p>
データソース構成画面上のプルダウン・メニューですべての有効なTNSサービス名リストを表示して選択することができます。</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblnote" --></div>
</li>
<li>
<p>ユーザーにデータベースへのアクセス権がない</p>
<br /> <span class="bold">問題:</span> ユーザーがOracle ODBC Driverを使用中にOracleデータベースへアクセスしようとすると、アクセス拒否のエラー・メッセージが戻される。<br /> <span class="bold">原因:</span> ユーザーにOracleデータベースへのアクセス権がない。<br /> <span class="bold">推奨処置:</span> Oracleデータベースへアクセスするための適切な権限がユーザーに割り当てられていることを確認します。</li>
<li>
<p>システム・エラー: ODBC DSNの作成時に182または193が発生</p>
<br /> <span class="bold">問題:</span> ODBC Administratorを使用したデータソース名の作成時に、Oracle ODBC Driverを選択後システム・エラー182または193が発生する。<br /> <span class="bold">原因:</span> Microsoftから提供される<code>mfc42.dll</code>との互換性の不一致。<br /> <span class="bold">推奨処置:</span> <code><span class="codeinlineitalic">OracleHome</span></code><code>/bin</code>が<code>PATH</code>に含まれていること、および<code><span class="codeinlineitalic">OracleHome</span></code><code>/bin</code>以外のパスに重複する<code>oci.dll</code>が存在しないことを確認します。それでもエラーが発生する場合は、正常に動作しているマシンから<code>mfc42.dll</code>をコピーします。</li>
<li>
<p>トランスレータ ライブラリを読み込めない(システム エラー コード31)</p>
<br /> <span class="bold">問題: </span>Oracle ODBC Driverを搭載したWindows上で、Microsoft ODBC AdministratorでOracle ODBC DSNを追加または削除すると、「トランスレータ ライブラリを読み込めません(システム エラー コード31)」が発生する。<br /> <span class="bold">原因:</span> Windowsマシンでは、旧バージョンの<code>mfc42.dll</code>が存在する場合があります。Oracle ODBCは<code>mfc42.dll</code>の新しいバージョン(バージョン6.0.8665.0)に対して作成されます。<br /> <span class="bold">推奨処置:</span> 旧バージョンの<code>mfc42.dll</code>がエラーを引き起こしています。MDAC 2.5 SP1をインストールしてもこの問題は解消されません。より新しいバージョンの<code>mfc42.dll</code>(バージョン6.0.8665.0以上)を入手し、<code><span class="codeinlineitalic">%</span></code><code>WINNT</code><code>%/System32</code>ディレクトリ内の古い<code>mfc42.dll</code>を次の方法で置換します。<br /> -- 正常に動作している別のマシンからコピーする<br /> -- dllの入手方法をMicrosoftに問い合せる</li>
</ul>
<div align="center">
<div class="inftblnote"><br />
<table border="1" cellpadding="3" cellspacing="0" class="Note oac_no_warn" frame="hsides" rules="groups" summary="" width="80%">
<tbody>
<tr>
<td align="left">
<p class="notep1">注意:</p>
このDLLは、Microsoft社のDLLです。</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblnote" --></div>
</div>
<!-- class="sect3" -->
<a id="BABGAIIC" name="BABGAIIC"></a><a id="ADFNS1161" name="ADFNS1161"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">期限切れパスワード</h4>
<p>この項には、期限切れパスワードに関する情報が含まれます。</p>
<a id="ADFNS1162" name="ADFNS1162"></a>
<p class="subhead2">期限切れパスワードの動作</p>
<p>データベースの接続時にパスワードが期限切れの場合、パスワードを変更するよう要求されます。正常にパスワードが変更されると、データベースに接続されます。ただし、<code>SQL_DRIVER_NOPROMPT</code>パラメータ値を使用して<code>SQLDriverConnect</code>コールでデータベースに接続すると、Oracle ODBC Driverはパスワードを変更するよう要求しません。かわりにエラーとなり、パスワードが期限切れであることを示すエラー番号およびメッセージを表示します。</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABGFHBE" name="BABGFHBE"></a><a id="ADFNS1163" name="ADFNS1163"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">上級ユーザー</h2>
<ul>
<li>
<p><a href="#BABCHHFC">Oracle ODBC DriverのTNSサービス名の作成</a></p>
</li>
<li>
<p><a href="#BABIDECD">SQL文</a></p>
</li>
<li>
<p><a href="#BABCIACJ">データ型</a></p>
</li>
<li>
<p><a href="#BABBAEEH">データ型の実装</a></p>
</li>
<li>
<p><a href="#BABBJIBH">データ型の制限</a></p>
</li>
<li>
<p><a href="#BABCCDFB">エラー・メッセージ</a></p>
</li>
</ul>
<a id="BABCHHFC" name="BABCHHFC"></a><a id="ADFNS1164" name="ADFNS1164"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Oracle ODBC DriverのTNSサービス名の作成</h3>
<p>Oracle Net Servicesを使用してOracle ODBC DriverのTNSサービス名を作成するには、Oracle Net Servicesと同時にインストールされるOracle Net Configuration Assistant (NETCA)を使用します。NETCAによって、Oracle ODBC DriverのTNSサービス名のエントリがtnsnames.oraファイルに作成されます。</p>
</div>
<!-- class="sect2" -->
<a id="BABIDECD" name="BABIDECD"></a><a id="ADFNS1165" name="ADFNS1165"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">SQL文</h3>
<p>Oracle ODBC DriverはSQL-92のエントリ・レベル仕様のスーパーセットであるSQL-99のコア仕様と広く互換性があります。Oracleの文法に加えて、ODBC仕様の付録Cで概要を説明しているベンダー固有のエスケープ・シーケンスもサポートしています。ODBCの設計に従って、Oracle ODBC Driverは固有のSQL構文をOracleデータベースに渡します。</p>
<a id="ADFNS1166" name="ADFNS1166"></a>
<p class="subhead2">上級ユーザー向け関連項目</p>
<p><a href="#BABCIACJ">データ型</a></p>
<a id="ADFNS1167" name="ADFNS1167"></a>
<p class="subhead2">プログラマ向け関連項目</p>
<p><a href="#BABIDAGF">ODBC SQL構文の実装</a></p>
</div>
<!-- class="sect2" -->
<a id="BABCIACJ" name="BABCIACJ"></a><a id="ADFNS1168" name="ADFNS1168"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">データ型</h3>
<p>Oracleデータベースのデータ型はOracle ODBC DriverによってODBCのSQLデータ型にマップされます。</p>
<div align="center">
<div class="inftblnote"><br />
<table border="1" cellpadding="3" cellspacing="0" class="Note oac_no_warn" frame="hsides" rules="groups" summary="" width="80%">
<tbody>
<tr>
<td align="left">
<p class="notep1">注意:</p>
<span class="italic">Microsoft ODBC 3.52 Software Development Kit and Programmers Reference</span>のAppendix Dにあるすべての変換は、適切な情報型を指定した<code>SQLGetInfo</code>のコールでリストされるODBC SQLデータ型についてサポートされています。</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblnote" --></div>
<a id="ADFNS1169" name="ADFNS1169"></a>
<p class="subhead2">上級ユーザー向け関連項目</p>
<p><a href="#BABBAEEH">データ型の実装</a></p>
<p><a href="#BABBJIBH">データ型の制限</a></p>
<p><a href="#BABIDECD">SQL文</a></p>
<a id="ADFNS1170" name="ADFNS1170"></a>
<p class="subhead2">プログラマ向け関連項目</p>
<p><a href="#BABEJGEG">データ型の実装(プログラミング)</a></p>
</div>
<!-- class="sect2" -->
<a id="BABBAEEH" name="BABBAEEH"></a><a id="ADFNS1171" name="ADFNS1171"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">データ型の実装</h3>
<ul>
<li>
<p><a href="#BABDCGGG">DATEおよびTIMESTAMP</a></p>
</li>
<li>
<p><a href="#BABBCEHB">浮動小数点のデータ型</a></p>
</li>
</ul>
<a id="BABDCGGG" name="BABDCGGG"></a><a id="ADFNS1172" name="ADFNS1172"></a>
<p class="subhead2">DATEおよびTIMESTAMP</p>
<p>Oracleの<code>DATE</code>データ型および<code>TIMESTAMP</code>データ型のセマンティクスは、同じ名前を持つODBCデータ型に正確には対応していません。Oracleの<code>DATE</code>データ型には日付情報および時間情報の両方が、<code>SQL_DATE</code>データ型には日付情報のみが含まれます。またOracleの<code>TIMESTAMP</code>データ型にも日付情報および時間情報が含まれますが、ここでは小数秒まで正確に表示されます。ODBCドライバでは、Oracleの<code>DATE</code>および<code>TIMESTAMP</code>列の両方のデータ型が<code>SQL_TIMESTAMP</code>としてレポートされ、情報の紛失が回避されています。また、ODBCドライバにより、<code>SQL_TIMESTAMP</code>パラメータがOracleの<code>TIMESTAMP</code>値としてバインドされます。</p>
<a id="BABBCEHB" name="BABBCEHB"></a><a id="ADFNS1173" name="ADFNS1173"></a>
<p class="subhead2">浮動小数点のデータ型</p>
<p>リリース10.1以降のOracleサーバーに接続すると、ODBCドライバにより、Oracleの浮動小数点のデータ型である<code>BINARY_FLOAT</code>および<code>BINARY_DOUBLE</code>が、ODBCデータ型である<code>SQL_REAL</code>および<code>SQL_DOUBLE</code>にそれぞれマップされます。以前のリリースでは、<code>SQL_REAL</code>および<code>SQL_DOUBLE</code>がOracleの汎用数値データ型にマップされていました。</p>
<a id="ADFNS1174" name="ADFNS1174"></a>
<p class="subhead2">関連トピック</p>
<p><a href="#BABDHDBB">DATEデータ型およびTIMESTAMPデータ型</a></p>
</div>
<!-- class="sect2" -->
<a id="BABBJIBH" name="BABBJIBH"></a><a id="ADFNS1175" name="ADFNS1175"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">データ型の制限</h3>
<p>Oracle ODBC DriverおよびOracleデータベースでは、データ型について制限があります。<a href="#BABIJGDI">表1-3</a>に、これらの制限を示します。</p>
<div class="tblformal"><a id="ADFNS1176" name="ADFNS1176"></a><a id="sthref10" name="sthref10"></a><a id="BABIJGDI" name="BABIJGDI"></a>
<p class="titleintable">表1-3 Oracle ODBC DriverおよびOracleデータベースがデータ型に課す制限</p>
<table border="1" cellpadding="3" cellspacing="0" class="Formal" dir="ltr" frame="hsides" rules="groups" summary="この表では、Oracle ODBC DriverおよびOracleデータベースによってデータ型に課される制限を説明しています。" title="Oracle ODBC DriverおよびOracleデータベースがデータ型に課す制限" width="100%">
<col width="31%" />
<col width="1*" />
<thead>
<tr align="left" valign="top">
<th id="r1c1-t13" align="left" valign="bottom">制限されるデータ型</th>
<th id="r1c2-t13" align="left" valign="bottom">説明</th>
</tr>
</thead>
<tbody>
<tr align="left" valign="top">
<td id="r2c1-t13" headers="r1c1-t13" align="left">
<p>リテラル</p>
</td>
<td headers="r2c1-t13 r1c2-t13" align="left">
<p>OracleデータベースではSQL文内のリテラルが4,000バイトに制限されます。</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r3c1-t13" headers="r1c1-t13" align="left">
<p>SQL_LONGVARCHARおよびSQL_WLONGVARCHAR</p>
</td>
<td headers="r3c1-t13 r1c2-t13" align="left">
<p><code>SQL_LONGVARCHAR</code>データ(<code>LONG</code>型)のOracleでの制限は2,147,483,647バイトです。<code>SQL_WLONGVARCHAR</code>データ(<code>CLOB</code>型)のOracleでの制限は4GBです。クライアント・ワークステーションのメモリーが制限の要因になります。</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r4c1-t13" headers="r1c1-t13" align="left">
<p>SQL_LONGVARCHARおよびSQL_LONGVARBINARY</p>
</td>
<td headers="r4c1-t13 r1c2-t13" align="left">
<p>Oracleデータベースでは1つの表ではLONGデータ列を1つしか使用できません。LONGデータ型には<code>SQL_LONGVARCHAR</code>(<code>LONG</code>)と<code>SQL_LONGVARBINARY</code>(<code>LONG RAW</code>)があります。かわりに<code>CLOB</code>および<code>BLOB</code>を使用することをお薦めします。1つの表で使用できる<code>CLOB</code>および<code>BLOB</code>列の数には、制限はありません。</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<a id="BABCCDFB" name="BABCCDFB"></a><a id="ADFNS1177" name="ADFNS1177"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">エラー・メッセージ</h3>
<p>エラーが発生すると、Oracle ODBC Driverは固有のエラー番号、<code>SQLSTATE</code>(ODBCエラー・コード)およびエラー・メッセージを戻します。Oracle ODBC Driverが検出したエラーとOracleサーバーが戻したエラーの両方から、Oracle ODBC Driverがこの情報を導出します。</p>
<a id="ADFNS1178" name="ADFNS1178"></a>
<p class="subhead2">固有のエラー</p>
<p>データソースで発生したエラーについては、Oracle ODBC DriverはOracleサーバーから戻された固有のエラーを戻します。Oracle ODBC Driverまたはドライバ・マネージャがエラーを検出した場合は、Oracle ODBC Driverは0 (ゼロ)という固有のエラーを戻します。</p>
<a id="ADFNS1179" name="ADFNS1179"></a>
<p class="subhead2">SQLSTATE</p>
<p>データソースで発生したエラーについては、Oracle ODBC Driverは戻された固有のエラーを適切な<code>SQLSTATE</code>にマップします。Oracle ODBC Driverがエラーを検出した場合は、Oracle ODBC Driverが適切な<code>SQLSTATE</code>を生成します。ドライバ・マネージャがエラーを検出した場合は、ドライバ・マネージャが適切な<code>SQLSTATE</code>を生成します。</p>
<a id="ADFNS1180" name="ADFNS1180"></a>
<p class="subhead2">エラー・メッセージ</p>
<p>データソースで発生したエラーについては、Oracle ODBC DriverはOracleサーバーから戻されたメッセージに基づくエラー・メッセージを戻します。Oracle ODBC Driverまたはドライバ・マネージャで発生したエラーについては、Oracle ODBC Driverは<code>SQLSTATE</code>に関連するテキストに基づくエラー・メッセージを戻します。</p>
<p>エラー・メッセージのフォーマットは次のとおりです。</p>
<pre xml:space="preserve" class="oac_no_warn">[vendor] [ODBC-component] [data-source] error-message<br /></pre>
<p>大カッコ([ ])内の接頭辞によってエラーのソースが識別されます。<a href="#BABFICEJ">表1-4</a>に、Oracle ODBC Driverが戻すこれらの接頭辞の値を示します。エラーがデータソースで発生したときは、[vendor]および[ODBC-component]という接頭辞によって、ベンダーと、データソースからエラーを受け取るODBCコンポーネントの名前が識別されます。</p>
<div class="tblformal"><a id="ADFNS1181" name="ADFNS1181"></a><a id="sthref11" name="sthref11"></a><a id="BABFICEJ" name="BABFICEJ"></a>
<p class="titleintable">表1-4 Oracle ODBC Driverが戻す接頭辞のエラー・メッセージ値</p>
<table border="1" cellpadding="3" cellspacing="0" class="Formal" dir="ltr" frame="hsides" rules="groups" summary="この表は、考えられる3つのエラー・ソースに基づいてOracle ODBC Driverが戻すこれらの接頭辞の値を示しています。" title="Oracle ODBC Driverが戻す接頭辞のエラー・メッセージ値" width="100%">
<col width="33%" />
<col width="27%" />
<col width="1*" />
<thead>
<tr align="left" valign="top">
<th id="r1c1-t14" align="left" valign="bottom">エラー・ソース</th>
<th id="r1c2-t14" align="left" valign="bottom">接頭辞</th>
<th id="r1c3-t14" align="left" valign="bottom">値</th>
</tr>
</thead>
<tbody>
<tr align="left" valign="top">
<td id="r2c1-t14" headers="r1c1-t14" align="left">
<p>ドライバ・マネージャ</p>
</td>
<td headers="r2c1-t14 r1c2-t14" align="left">
<p>[vendor][ODBC-component][data-source]</p>
</td>
<td headers="r2c1-t14 r1c3-t14" align="left">
<p>[Microsoft/unixODBC][ODBC Driver Manager]N/A</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r3c1-t14" headers="r1c1-t14" align="left">
<p>Oracle ODBC Driver</p>
</td>
<td headers="r3c1-t14 r1c2-t14" align="left">
<p>[vendor][ODBC-component][data-source]</p>
</td>
<td headers="r3c1-t14 r1c3-t14" align="left">
<p>[ORACLE][ODBC Driver]N/A</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r4c1-t14" headers="r1c1-t14" align="left">
<p>Oracleサーバー</p>
</td>
<td headers="r4c1-t14 r1c2-t14" align="left">
<p>[vendor][ODBC-component][data-source]</p>
</td>
<td headers="r4c1-t14 r1c3-t14" align="left">
<p>[ORACLE][ODBC Driver]N/A</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>たとえば、次に示すフォーマットのようにエラー・メッセージに[Ora]という接頭辞が含まれない場合、そのエラーはOracle ODBC Driverのエラーであり、自明であるために接頭辞が省略されています。</p>
<pre xml:space="preserve" class="oac_no_warn">[Oracle][ODBC]Error message text here <br /></pre>
<p>次に示すフォーマットのようにエラー・メッセージに[Ora]という接頭辞が含まれる場合、Oracle ODBC Driverのエラーではありません。エラー・メッセージに接頭辞[Ora]が含まれていても、実際のエラーはいくつかのソースの1つで発生している可能性があることに注意してください。</p>
<pre xml:space="preserve" class="oac_no_warn">[Oracle][ODBC][Ora]Error message text here <br /></pre>
<p>エラー・メッセージのテキストが次に示す接頭辞で始まる場合は、そのエラーについての詳しい情報がOracleサーバーのマニュアルに記載されています。</p>
<pre xml:space="preserve" class="oac_no_warn">ORA-<br /></pre>
<p>Oracle Net Servicesエラーおよびトレース・ロギングは、OCIソフトウェアがインストールされたWindowsシステムの<code><span class="codeinlineitalic">ORACLE_HOME</span></code><code>\NETWORK</code>ディレクトリまたはUNIXシステムの<code><span class="codeinlineitalic">ORACLE_HOME</span></code><code>/NETWORK</code>ディレクトリの下、具体的にはそれぞれlogディレクトリとtraceディレクトリにあります。データベース・ロギングは、Oracleサーバー・ソフトウェアがインストールされたWindowsシステムの<code><span class="codeinlineitalic">ORACLE_HOME</span></code><code>\RDBMS</code>ディレクトリまたはUNIXシステムの<code><span class="codeinlineitalic">ORACLE_HOME</span></code><code>/rdbms</code>ディレクトリにあります。</p>
<p>サーバーのエラー・メッセージの詳細は、Oracleサーバーのマニュアルを参照してください。</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABICHJC" name="BABICHJC"></a><a id="ADFNS1182" name="ADFNS1182"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">プログラマ</h2>
<ul>
<li>
<p><a href="#BABIJAGI">接続文字列のフォーマット</a></p>
</li>
<li>
<p><a href="#BABIDEDG">SQLDriverConnectの実装</a></p>
</li>
<li>
<p><a href="#BABCEBFI">プログラムでのロック・タイムアウトの短縮</a></p>
</li>
<li>
<p><a href="#BABJJDBG">odbc32.lib (Windows)またはlibodbc.so (UNIX)とのリンク</a></p>
</li>
<li>
<p><a href="#BABCEAIA">ROWIDの情報の取得</a></p>
</li>
<li>
<p><a href="#BABBBDEJ">WHERE句でのROWID</a></p>
</li>
<li>
<p><a href="#BABHGBFJ">結果セットの有効化</a></p>
</li>
<li>
<p><a href="#BABJCDGE">EXEC構文の有効化</a></p>
</li>
<li>
<p><a href="#BABGJGBA">Oracle RAC環境における接続障害のイベント通知の有効化</a></p>
</li>
<li>
<p><a href="#BABDDGBE">ODBCを通じた暗黙的結果機能の使用</a></p>
</li>
<li>
<p><a href="#BABBCCDD">サポートされる機能</a></p>
</li>
<li>
<p><a href="#BABIFIGA">Unicodeサポート</a></p>
</li>
<li>
<p><a href="#BABIIAIH">パフォーマンスおよびチューニング</a></p>
</li>
</ul>
<a id="BABIJAGI" name="BABIJAGI"></a><a id="ADFNS1183" name="ADFNS1183"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">接続文字列のフォーマット</h3>
<p><a href="#BABEFBFB">表1-5</a>に<code>SQLDriverConnect</code>関数コールの接続文字列引数に組み込むことができるキーワードを示します。指定されていないキーワードは、データソースのAdministratorのエントリから読み込まれます。接続文字列に指定される値はAdministratorのエントリに格納されている値を上書きします。<code>SQLDriverConnect</code>関数の詳細は、<span class="italic">Microsoft ODBC 3.52 Software Development Kit and Programmers Reference</span>を参照してください。</p>
<div class="tblformal"><a id="ADFNS1184" name="ADFNS1184"></a><a id="sthref12" name="sthref12"></a><a id="BABEFBFB" name="BABEFBFB"></a>
<p class="titleintable">表1-5 SQLDriverConnect関数コールの接続文字列引数に組み込むことができるキーワード</p>
<table border="1" cellpadding="3" cellspacing="0" class="Formal" dir="ltr" frame="hsides" rules="groups" summary="この表では、SQLDrivedConnect関数の接続文字列引数に組み込むことができるキーワードを示しています。" title="SQLDriverConnect関数コールの接続文字列引数に組み込むことができるキーワード" width="100%">
<col width="13%" />
<col width="37%" />
<col width="1*" />
<thead>
<tr align="left" valign="top">
<th id="r1c1-t15" align="left" valign="bottom">キーワード</th>
<th id="r1c2-t15" align="left" valign="bottom">意味</th>
<th id="r1c3-t15" align="left" valign="bottom">コメント</th>
</tr>
</thead>
<tbody>
<tr align="left" valign="top">
<td id="r2c1-t15" headers="r1c1-t15" align="left">
<p>DSN</p>
</td>
<td headers="r2c1-t15 r1c2-t15" align="left">
<p>ODBCデータソース名</p>
</td>
<td headers="r2c1-t15 r1c3-t15" align="left">
<p>ユーザー指定名。</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r3c1-t15" headers="r1c1-t15" align="left">
<p>DBQ</p>
</td>
<td headers="r3c1-t15 r1c2-t15" align="left">
<p>TNSサービス名</p>
</td>
<td headers="r3c1-t15 r1c3-t15" align="left">
<p>ユーザー指定名。</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r4c1-t15" headers="r1c1-t15" align="left">
<p>UID</p>
</td>
<td headers="r4c1-t15 r1c2-t15" align="left">
<p>ユーザーIDまたはユーザー名</p>
</td>
<td headers="r4c1-t15 r1c3-t15" align="left">
<p>ユーザー指定名。</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r5c1-t15" headers="r1c1-t15" align="left">
<p>PWD</p>
</td>
<td headers="r5c1-t15 r1c2-t15" align="left">
<p>パスワード</p>
</td>
<td headers="r5c1-t15 r1c3-t15" align="left">
<p>ユーザー指定パスワード。空のパスワードに対しては、PWD=;と指定。</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r6c1-t15" headers="r1c1-t15" align="left">
<p>DBA</p>
</td>
<td headers="r6c1-t15 r1c2-t15" align="left">
<p>データベース属性</p>
</td>
<td headers="r6c1-t15 r1c3-t15" align="left">
<p>W=書込みアクセス。R=読取り専用アクセス。</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r7c1-t15" headers="r1c1-t15" align="left">
<p>APA</p>
</td>
<td headers="r7c1-t15 r1c2-t15" align="left">
<p>アプリケーション属性</p>
</td>
<td headers="r7c1-t15 r1c3-t15" align="left">
<p>T=スレッド・セーフティ有効。F=スレッド・セーフティ無効。</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r8c1-t15" headers="r1c1-t15" align="left">
<p>RST</p>
</td>
<td headers="r8c1-t15 r1c2-t15" align="left">
<p>結果セット</p>
</td>
<td headers="r8c1-t15 r1c3-t15" align="left">
<p>T=結果セット有効。F=結果セット無効。</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r9c1-t15" headers="r1c1-t15" align="left">
<p>QTO</p>
</td>
<td headers="r9c1-t15 r1c2-t15" align="left">
<p>問合せタイムアウトのオプション</p>
</td>
<td headers="r9c1-t15 r1c3-t15" align="left">
<p>T=クエリー・タイムアウト有効。F=クエリー・タイムアウト無効。</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r10c1-t15" headers="r1c1-t15" align="left">
<p>CSR</p>
</td>
<td headers="r10c1-t15 r1c2-t15" align="left">
<p>カーソル・クローズ</p>
</td>
<td headers="r10c1-t15 r1c3-t15" align="left">
<p>T=カーソル・クローズ有効。F=カーソル・クローズ無効。</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r11c1-t15" headers="r1c1-t15" align="left">
<p>BNF</p>
</td>
<td headers="r11c1-t15 r1c2-t15" align="left">
<p><code>NUMBER</code>を<code>FLOAT</code>としてバインド</p>
</td>
<td headers="r11c1-t15 r1c3-t15" align="left">
<p>T=<code>NUMBER</code>を<code>FLOAT</code>としてバインド。F=<code>NUMBER</code>を<code>NUMBER</code>としてバインド。</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r12c1-t15" headers="r1c1-t15" align="left">
<p>DRH</p>
</td>
<td headers="r12c1-t15 r1c2-t15" align="left">
<p>RULEヒントを無効化</p>
</td>
<td headers="r12c1-t15 r1c3-t15" align="left">
<p>T=RULEヒントを無効化。F=RULEヒントを有効化。</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r13c1-t15" headers="r1c1-t15" align="left">
<p>BAM</p>
</td>
<td headers="r13c1-t15 r1c2-t15" align="left">
<p>バッチ自動コミット・モード</p>
</td>
<td headers="r13c1-t15 r1c3-t15" align="left">
<p>IfAllSuccessful=すべての文が正常終了した場合のみ、コミット(以前の動作)。UpToFirstFailure=最初の失敗の文までコミット(V7 ODBCの動作)。AllSuccessful=すべての正常終了した文をコミット(Oracleデータベースに接続されている場合のみ。他のデータベースの場合、V7と同じ動作)。</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r14c1-t15" headers="r1c1-t15" align="left">
<p>FBS</p>
</td>
<td headers="r14c1-t15 r1c2-t15" align="left">
<p>フェッチ・バッファ・サイズ</p>
</td>
<td headers="r14c1-t15 r1c3-t15" align="left">
<p>ユーザー指定の数値(バイト単位で0以上を指定)。デフォルトは60,000バイトです。</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r15c1-t15" headers="r1c1-t15" align="left">
<p>FEN</p>
</td>
<td headers="r15c1-t15 r1c2-t15" align="left">
<p>フェイルオーバー</p>
</td>
<td headers="r15c1-t15 r1c3-t15" align="left">
<p>T=フェイルオーバー有効。F=フェイルオーバー無効。</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r16c1-t15" headers="r1c1-t15" align="left">
<p>FRC</p>
</td>
<td headers="r16c1-t15 r1c2-t15" align="left">
<p>フェイルオーバー再試行数</p>
</td>
<td headers="r16c1-t15 r1c3-t15" align="left">
<p>ユーザー指定の数値。デフォルトは10です。</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r17c1-t15" headers="r1c1-t15" align="left">
<p>FDL</p>
</td>
<td headers="r17c1-t15 r1c2-t15" align="left">
<p>フェイルオーバー遅延</p>
</td>
<td headers="r17c1-t15 r1c3-t15" align="left">
<p>ユーザー指定の数値。デフォルトは10です。</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r18c1-t15" headers="r1c1-t15" align="left">
<p>LOB</p>
</td>
<td headers="r18c1-t15 r1c2-t15" align="left">
<p>LOB書込み</p>
</td>
<td headers="r18c1-t15 r1c3-t15" align="left">
<p>T=LOB有効。F=LOB無効。</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r19c1-t15" headers="r1c1-t15" align="left">
<p>MTS</p>
</td>
<td headers="r19c1-t15 r1c2-t15" align="left">
<p>Microsoft Transaction Serverサポート</p>
</td>
<td headers="r19c1-t15 r1c3-t15" align="left">
<p>T=無効。F=有効。</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r20c1-t15" headers="r1c1-t15" align="left">
<p>FWC</p>
</td>
<td headers="r20c1-t15 r1c2-t15" align="left">
<p><code>SQL_WCHAR</code>強制サポート</p>
</td>
<td headers="r20c1-t15 r1c3-t15" align="left">
<p>T=強制<code>SQL_WCHAR</code>有効。F=強制<code>SQL_WCHAR</code>無効。</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r21c1-t15" headers="r1c1-t15" align="left">
<p>EXC</p>
</td>
<td headers="r21c1-t15 r1c2-t15" align="left">
<p>EXEC構文</p>
</td>
<td headers="r21c1-t15 r1c3-t15" align="left">
<p>T=EXEC構文有効。F=EXEC構文無効。</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r22c1-t15" headers="r1c1-t15" align="left">
<p>XSM</p>
</td>
<td headers="r22c1-t15 r1c2-t15" align="left">
<p>スキーマ・フィールド</p>
</td>
<td headers="r22c1-t15 r1c3-t15" align="left">
<p>Default=デフォルト。Database=データベース名。Owner=所有者名。</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r23c1-t15" headers="r1c1-t15" align="left">
<p>MDI</p>
</td>
<td headers="r23c1-t15 r1c2-t15" align="left">
<p>メタデータIDのデフォルトの設定</p>
</td>
<td headers="r23c1-t15 r1c3-t15" align="left">
<p>T=<code>SQL_ATTR_METADATA_ID</code>のデフォルトを<code>SQL_TRUE</code>に設定。F=<code>SQL_ATTR_METADATA_ID</code>のデフォルトを<code>SQL_FALSE</code>に設定。</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r24c1-t15" headers="r1c1-t15" align="left">
<p>DPM</p>
</td>
<td headers="r24c1-t15 r1c2-t15" align="left">
<p><code>SQLDescribeParam</code>の無効化</p>
</td>
<td headers="r24c1-t15 r1c3-t15" align="left">
<p>T=<code>SQLDescribeParam</code>無効。F=<code>SQLDescribeParam</code>有効。</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r25c1-t15" headers="r1c1-t15" align="left">
<p>BTD</p>
</td>
<td headers="r25c1-t15 r1c2-t15" align="left">
<p><code>TIMESTAMP</code>を<code>DATE</code>としてバインド</p>
</td>
<td headers="r25c1-t15 r1c3-t15" align="left">
<p>T=<code>SQL_TIMESTAMP</code>をOracle <code>DATE</code>でバインド F=<code>SQL_TIMESTAMP</code>をOracle <code>TIMESTAMP</code>でバインド</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r26c1-t15" headers="r1c1-t15" align="left">
<p>NUM</p>
</td>
<td headers="r26c1-t15 r1c2-t15" align="left">
<p>数値の設定</p>
</td>
<td headers="r26c1-t15 r1c3-t15" align="left">
<p>NLS=Oracle NLS数値設定を使用(小数点および3桁区切りの決定)。MS=Microsoftの地域設定を使用。US=US設定を使用。</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r27c1-t15" headers="r1c1-t15" align="left">
<p>ODA</p>
</td>
<td headers="r27c1-t15 r1c2-t15" align="left">
<p><code>OCIDescribeAny( )</code>を使用</p>
</td>
<td headers="r27c1-t15 r1c3-t15" align="left">
<p>T=アプリケーションが<code>REF CURSORS</code>を戻す小さなパッケージ・プロシージャを頻繁にコールする場合にパフォーマンスを向上させるために<code>OCIDescribeAny( )</code>コールを使用。</p>
<p>F=<code>OCIDescribeAny( )</code>を使用しない。デフォルトでは、<code>OCIDescribeAny( )</code>値の使用は<code>FALSE</code>です。</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r28c1-t15" headers="r1c1-t15" align="left">
<p>STE</p>
</td>
<td headers="r28c1-t15 r1c2-t15" align="left">
<p>SQLでORAエラーを変換</p>
<p>Oracle ODBC DriverがOracleエラー・コードを変換するかどうかを指定</p>
</td>
<td headers="r28c1-t15 r1c3-t15" align="left">
<p>T=ORAエラーを変換。</p>
<p>F=ORAエラーを変換しない。デフォルトでは、<code>SQLTranslateErrors</code>は<code>FALSE</code>に設定されます。</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r29c1-t15" headers="r1c1-t15" align="left">
<p>TSZ</p>
</td>
<td headers="r29c1-t15 r1c2-t15" align="left">
<p>トークン・サイズ</p>
</td>
<td headers="r29c1-t15 r1c3-t15" align="left">
<p>ユーザー指定の数値。</p>
<p>トークン・サイズを4 KB (4096バイト)から開始する最も近い1 KB (1024バイト)の倍数に設定します。デフォルト・サイズは8 KB (8192バイト)です。設定できる最大値は128 KB (131068バイト)です。</p>
</td>
</tr>
<tr align="left" valign="top">
<td></td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>次のキーワードが接続文字列に指定された場合、Oracle ODBC DriverはAdministratorで定義されているどの値も読み取りません。</p>
<pre xml:space="preserve" class="oac_no_warn">DRIVER={Oracle ODBC Driver}<br /></pre>
<p>有効な接続文字列の例:</p>
<pre xml:space="preserve" class="oac_no_warn">1) DSN=Personnel;UID=Kotzwinkle;PWD=;2) DRIVER={Oracle ODBC Driver};UID=Kotzwinkle;PWD=whatever;DBQ=instl_alias;DBA=W;<br /></pre>
<p>追加情報にアクセスするには、次のリンクのいずれかをクリックします。</p>
<a id="ADFNS1185" name="ADFNS1185"></a>
<p class="subhead2">全ユーザー向け関連項目</p>
<p><a href="#BABDCHIG">Oracleデータソースへの接続</a></p>
<a id="ADFNS1186" name="ADFNS1186"></a>
<p class="subhead2">プログラマ向け関連項目</p>
<p><a href="#BABIDEDG">SQLDriverConnectの実装</a></p>
</div>
<!-- class="sect2" -->
<a id="BABIDEDG" name="BABIDEDG"></a><a id="ADFNS1188" name="ADFNS1188"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">SQLDriverConnectの実装</h3>
<div class="tblformal"><a id="ADFNS1189" name="ADFNS1189"></a><a id="sthref13" name="sthref13"></a><a id="BABGEAEC" name="BABGEAEC"></a>
<p class="titleintable">表1-6 SQLDriverConnect接続文字列で必要なキーワード</p>
<table border="1" cellpadding="3" cellspacing="0" class="Formal" dir="ltr" frame="hsides" rules="groups" summary="この表では、SQLDriverConnect接続文字列で必要なキーワードを説明しています。" title="SQLDriverConnect接続文字列で必要なキーワード" width="100%">
<col width="31%" />
<col width="1*" />
<thead>
<tr align="left" valign="top">
<th id="r1c1-t16" align="left" valign="bottom">キーワード</th>
<th id="r1c2-t16" align="left" valign="bottom">説明</th>
</tr>
</thead>
<tbody>
<tr align="left" valign="top">
<td id="r2c1-t16" headers="r1c1-t16" align="left">
<p>DSN</p>
</td>
<td headers="r2c1-t16 r1c2-t16" align="left">
<p>データソース名。</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r3c1-t16" headers="r1c1-t16" align="left">
<p>DBQ</p>
</td>
<td headers="r3c1-t16 r1c2-t16" align="left">
<p>TNSサービス名。<a href="#BABCHHFC">「Oracle ODBC DriverのTNSサービス名の作成」</a>を参照してください。詳細は、Oracle Net Servicesのマニュアルを参照してください。</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r4c1-t16" headers="r1c1-t16" align="left">
<p>UID</p>
</td>
<td headers="r4c1-t16 r1c2-t16" align="left">
<p>ユーザーのログインIDまたはユーザー名。</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r5c1-t16" headers="r1c1-t16" align="left">
<p>PWD</p>
</td>
<td headers="r5c1-t16 r1c2-t16" align="left">
<p>ユーザー指定のパスワード。</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<a id="BABCEBFI" name="BABCEBFI"></a><a id="ADFNS1190" name="ADFNS1190"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">プログラムでのロック・タイムアウトの短縮</h3>
<p>Oracleサーバーは、トランザクション間のロック競合が解消されるまで無期限に待機します。データソースに接続する前にODBC <code>SQLSetConnectAttr</code>関数をコールすることによって、ロック解消をOracleサーバーが待機する時間の長さを制限できます。ODBC <code>SQLSetStmtAttr</code>関数の<code>SQL_ATTR_QUERY_TIMEOUT</code>属性に0 (ゼロ)以外の値を指定します。</p>
<p>ODBC <code>SQLSetConnectAttr</code>関数を使用してロック・タイムアウト値を指定すると、その値によってoraodbc.iniファイルに指定されている値が上書きされます。<code>oraodbc.ini</code>ファイルに値を指定する方法の詳細は、<a href="#BABEGGIB">「ロック・タイムアウトを短縮する」</a>を参照してください。</p>
</div>
<!-- class="sect2" -->
<a id="BABJJDBG" name="BABJJDBG"></a><a id="ADFNS1191" name="ADFNS1191"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">odbc32.lib (Windows)またはlibodbc.so (UNIX)とのリンク</h3>
<p>Windowsプラットフォームの場合、プログラムをリンクするときは、インポート・ライブラリ<code>odbc32.lib</code>とリンクする必要があります。</p>
<p>UNIXプラットフォームの場合は、ODBCアプリケーションを<code>libodbc.so</code>にリンクする必要があります。</p>
</div>
<!-- class="sect2" -->
<a id="BABCEAIA" name="BABCEAIA"></a><a id="ADFNS1192" name="ADFNS1192"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">ROWIDの情報の取得</h3>
<p>ODBC <code>SQLSpecialColumns</code>関数は表の列に関する情報を戻します。Oracle ODBC Driverでは、Oracle表に対応付けられているOracleのROWIDについての情報が戻されます。</p>
</div>
<!-- class="sect2" -->
<a id="BABBBDEJ" name="BABBBDEJ"></a><a id="ADFNS1193" name="ADFNS1193"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">WHERE句でのROWID</h3>
<p>ROWIDはSQL文の<code>WHERE</code>句で使用できます。ただし、ROWID値はパラメータ・マーカー内で使用する必要があります。</p>
</div>
<!-- class="sect2" -->
<a id="BABHGBFJ" name="BABHGBFJ"></a><a id="ADFNS1194" name="ADFNS1194"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">結果セットの有効化</h3>
<p>Oracleの参照カーソル(結果セット)によって、アプリケーションはストアド・ファンクションやストアド・プロシージャを使用してデータを取り出せるようになります。次にODBCを介して結果セットを使用可能にする方法を示します。</p>
<ul>
<li>
<p>ストアド・プロシージャのコールにはODBC構文を使用する必要があります。ネイティブのPL/SQLはODBCからはサポートされていません。次にパッケージ内のおよびパッケージなしのプロシージャまたはファンクションのコール方法を示します。ここでのパッケージ名をRSETとします。</p>
<pre xml:space="preserve" class="oac_no_warn">Procedure call: <br />{CALL Example1(?)}<br />{CALL RSET.Example1(?)} <br />Function Call: <br />{? = CALL Example1(?)}<br />{? = CALL RSET.Example1(?)} <br /></pre></li>
<li>
<p>PL/SQLの参照カーソル・パラメータは、プロシージャのコール時に省略されます。たとえば、Example2プロシージャが4つのパラメータを持つと仮定します。パラメータ1と3は参照カーソルで、パラメータ2と4は文字列です。コールは次のように指定されます。</p>
<pre xml:space="preserve" class="oac_no_warn">{CALL RSET.Example2("Literal 1", "Literal 2")}<br /></pre></li>
</ul>
<p>次のサンプル・アプリケーションでは、Oracle ODBC Driverを使用して結果セットを返す方法を示します。</p>
<pre xml:space="preserve" class="oac_no_warn">/* <br />* Sample Application using Oracle reference cursors via ODBC <br />* <br />* Assumptions: <br />* <br />* 1) Oracle Sample database is present with data loaded for the EMP table. <br />* <br />* 2) Two fields are referenced from the EMP table ename and mgr. <br />* <br />* 3) A data source has been setup to access the sample database. <br />* <br />* <br />* Program Description: <br />* <br />* Abstract: <br />* <br />* This program demonstrates how to return result sets using <br />* Oracle stored procedures <br />* <br />* Details: <br />* <br />* This program: <br />* Creates an ODBC connection to the database. <br />* Creates a Packaged Procedure containing two result sets. <br />* Executes the procedure and retrieves the data from both result sets.<br />* Displays the data to the user.<br />* Deletes the package then logs the user out of the database. <br />* <br />* <br />* The following is the actual PL/SQL this code generates to <br />* create the stored procedures. <br />* <br />DROP PACKAGE ODBCRefCur; <br />CREATE PACKAGE ODBCRefCur AS <br />TYPE ename_cur IS REF CURSOR; <br />TYPE mgr_cur IS REF CURSOR; <br />PROCEDURE EmpCurs(Ename IN OUT ename_cur, Mgr IN OUT mgr_cur, pjob IN VARCHAR2); <br /> <br /> <br /> <br />END; <br />/ <br />CREATE PACKAGE BODY ODBCRefCur AS <br />PROCEDURE EmpCurs(Ename IN OUT ename_cur, Mgr IN OUT mgr_cur, pjob IN VARCHAR2) <br />AS <br />BEGIN <br />IF NOT Ename%ISOPEN <br />THEN <br />OPEN Ename for SELECT ename from emp; <br />END IF; <br /> <br /> <br /> <br />IF NOT Mgr%ISOPEN <br />THEN <br />OPEN Mgr for SELECT mgr from emp where job = pjob; <br />END IF; <br />END; <br />END; <br />/ <br /> <br /> <br /> <br />* <br />* End PL/SQL for Reference Cursor. <br />*/ <br /> <br /> <br /> <br />/* <br />* Include Files <br />*/ <br />#include &lt;windows.h&gt; <br />#include &lt;stdio.h&gt; <br />#include &lt;sql.h&gt; <br />#include &lt;sqlext.h&gt; <br /> <br /> <br /> <br />/* <br />* Defines <br />*/ <br />#define JOB_LEN 9 <br />#define DATA_LEN 100 <br />#define SQL_STMT_LEN 500 <br /> <br /> <br /> <br />/* <br />* Procedures <br />*/ <br />void DisplayError( SWORD HandleType, SQLHANDLE hHandle, char *Module ); <br /> <br />/* <br />* Main Program <br />*/ <br />int main() <br />{ <br />SQLHENV hEnv; <br />SQLHDBC hDbc; <br />SQLHSTMT hStmt; <br />SQLRETURN rc; <br />char *DefUserName ="scott"; <br />char *DefPassWord ="tiger"; <br />SQLCHAR ServerName[DATA_LEN]; <br />SQLCHAR *pServerName=ServerName; <br />SQLCHAR UserName[DATA_LEN]; <br />SQLCHAR *pUserName=UserName; <br />SQLCHAR PassWord[DATA_LEN]; <br />SQLCHAR *pPassWord=PassWord; <br />char Data[DATA_LEN]; <br />SQLINTEGER DataLen; <br />char error[DATA_LEN]; <br />char *charptr; <br />SQLCHAR SqlStmt[SQL_STMT_LEN]; <br />SQLCHAR *pSqlStmt=SqlStmt; <br />char *pSalesMan = "SALESMAN"; <br />SQLINTEGER sqlnts=SQL_NTS; <br /> <br /> <br /> <br />/* <br />* Allocate the Environment Handle <br />*/ <br />rc = SQLAllocHandle( SQL_HANDLE_ENV, SQL_NULL_HANDLE, &amp;hEnv ); <br />if (rc != SQL_SUCCESS) <br />{ <br />printf( "Cannot Allocate Environment Handle/n"); <br />printf( "/nHit Return to Exit/n"); <br />charptr = gets ((char *)error); <br />exit(1); <br />} <br /> <br /> <br /> <br />/* <br />* Set the ODBC Version <br />*/ <br />rc = SQLSetEnvAttr( hEnv, <br />SQL_ATTR_ODBC_VERSION, <br />(void *)SQL_OV_ODBC3, <br />0); <br />if (rc != SQL_SUCCESS) <br />{ <br />printf( "Cannot Set ODBC Version/n"); <br />printf( "/nHit Return to Exit/n"); <br />charptr = gets ((char *)error); <br />exit(1); <br />} <br /> <br /> <br /> <br />/* <br />* Allocate the Connection handle <br />*/ <br />rc = SQLAllocHandle( SQL_HANDLE_DBC, hEnv, &amp;hDbc ); <br />if (rc != SQL_SUCCESS) <br />{ <br />printf( "Cannot Allocate Connection Handle/n"); <br />printf( "/nHit Return to Exit/n"); <br />charptr = gets ((char *)error); <br />exit(1); <br />} <br /> <br /> <br /> <br />/* <br />* Get User Information <br />*/ <br />lstrcpy( (char *) pUserName, DefUserName ); <br />lstrcpy( (char *) pPassWord, DefPassWord ); <br /> <br /> <br /> <br />/* <br />* Data Source name <br />*/ <br />printf( "/nEnter the ODBC Data Source Name/n" ); <br />charptr = gets ((char *) ServerName); <br /> <br /> <br /> <br />/* <br />* User Name <br />*/ <br />printf ( "/nEnter User Name Default [%s]/n", pUserName); <br />charptr = gets ((char *) UserName); <br />if (*charptr == '/0') <br />{ <br />lstrcpy( (char *) pUserName, (char *) DefUserName ); <br />} <br /> <br /> <br /> <br />/* <br />* Password <br />*/ <br />printf ( "/nEnter Password Default [%s]/n", pPassWord); <br />charptr = gets ((char *)PassWord); <br />if (*charptr == '/0') <br />{ <br />lstrcpy( (char *) pPassWord, (char *) DefPassWord ); <br />} <br /> <br /> <br /> <br />/* <br />* Connection to the database <br />*/ <br />rc = SQLConnect( hDbc, <br />pServerName, <br />(SQLSMALLINT) lstrlen((char *)pServerName), <br />pUserName, <br />(SQLSMALLINT) lstrlen((char *)pUserName), <br />pPassWord, <br />(SQLSMALLINT) lstrlen((char *)pPassWord)); <br />if (rc != SQL_SUCCESS) <br />{ <br />DisplayError(SQL_HANDLE_DBC, hDbc, "SQLConnect"); <br />} <br /> <br /> <br /> <br />/* <br />* Allocate a Statement <br />*/ <br />rc = SQLAllocHandle( SQL_HANDLE_STMT, hDbc, &amp;hStmt ); <br />if (rc != SQL_SUCCESS) <br />{ <br />printf( "Cannot Allocate Statement Handle/n"); <br />printf( "/nHit Return to Exit/n"); <br />charptr = gets ((char *)error); <br />exit(1); <br />} <br /> <br /> <br /> <br />/* <br />* Drop the Package <br />*/ <br />lstrcpy( (char *) pSqlStmt, "DROP PACKAGE ODBCRefCur"); <br />rc = SQLExecDirect(hStmt, pSqlStmt, lstrlen((char *)pSqlStmt)); <br /> <br /> <br /> <br />/* <br />* Create the Package Header <br />*/ <br />lstrcpy( (char *) pSqlStmt, "CREATE PACKAGE ODBCRefCur AS/n"); <br />lstrcat( (char *) pSqlStmt, " TYPE ename_cur IS REF CURSOR;/n"); <br />lstrcat( (char *) pSqlStmt, " TYPE mgr_cur IS REF CURSOR;/n/n"); <br />lstrcat( (char *) pSqlStmt, " PROCEDURE EmpCurs (Ename IN OUT ename_cur,"); <br />lstrcat( (char *) pSqlStmt, "Mgr IN OUT mgr_cur,pjob IN VARCHAR2);/n/n"); <br />lstrcat( (char *) pSqlStmt, "END;/n"); <br />rc = SQLExecDirect(hStmt, pSqlStmt, lstrlen((char *)pSqlStmt)); <br />if (rc != SQL_SUCCESS) <br />{ <br />DisplayError(SQL_HANDLE_STMT, hStmt, "SQLExecDirect"); <br />} <br /> <br /> <br /> <br />/* <br />* Create the Package Body <br />*/ <br />lstrcpy( (char *) pSqlStmt, "CREATE PACKAGE BODY ODBCRefCur AS/n"); <br />lstrcat( (char *) pSqlStmt, " PROCEDURE EmpCurs (Ename IN OUT ename_cur,"); <br />lstrcat( (char *) pSqlStmt, "Mgr IN OUT mgr_cur, pjob IN VARCHAR2)/n AS/n BEGIN/n"); <br />lstrcat( (char *) pSqlStmt, " IF NOT Ename%ISOPEN/n THEN/n"); <br />lstrcat( (char *) pSqlStmt, " OPEN Ename for SELECT ename from emp;/n"); <br />lstrcat( (char *) pSqlStmt, " END IF;/n/n"); <br />lstrcat( (char *) pSqlStmt, " IF NOT Mgr%ISOPEN/n THEN/n"); <br />lstrcat( (char *) pSqlStmt, " OPEN Mgr for SELECT mgr from emp where job = pjob;/n"); <br />lstrcat( (char *) pSqlStmt, " END IF;/n"); <br />lstrcat( (char *) pSqlStmt, " END;/n"); <br />lstrcat( (char *) pSqlStmt, "END;/n"); <br />rc = SQLExecDirect(hStmt, pSqlStmt, lstrlen((char *)pSqlStmt)); <br />if (rc != SQL_SUCCESS) <br />{ <br />DisplayError(SQL_HANDLE_STMT, hStmt, "SQLExecDirect"); <br />} <br /> <br /> <br /> <br />/* <br />* Bind the Parameter <br />*/ <br />rc = SQLBindParameter(hStmt, <br />1, <br />SQL_PARAM_INPUT, <br />SQL_C_CHAR, <br />SQL_CHAR, <br />JOB_LEN, <br />0, <br />pSalesMan, <br />0, <br />&amp;sqlnts); <br /> <br /> <br /> <br />/* <br />* Call the Store Procedure which executes the Result Sets <br />*/ <br />lstrcpy( (char *) pSqlStmt, "{CALL ODBCRefCur.EmpCurs(?)}"); <br />rc = SQLExecDirect(hStmt, pSqlStmt, lstrlen((char *)pSqlStmt)); <br />if (rc != SQL_SUCCESS) <br />{ <br />DisplayError(SQL_HANDLE_STMT, hStmt, "SQLExecDirect"); <br />} <br /> <br /> <br /> <br />/* <br />* Bind the Data <br />*/ <br />rc = SQLBindCol( hStmt, <br />1, <br />SQL_C_CHAR, <br />Data, <br />sizeof(Data), <br />&amp;DataLen); <br />if (rc != SQL_SUCCESS) <br />{ <br />DisplayError(SQL_HANDLE_STMT, hStmt, "SQLBindCol"); <br />} <br /> <br /> <br /> <br />/* <br />* Get the data for Result Set 1 <br />*/ <br />printf( "/nEmployee Names/n/n"); <br />while ( rc == SQL_SUCCESS ) <br />{ <br />rc = SQLFetch( hStmt ); <br />if ( rc == SQL_SUCCESS ) <br />{ <br />printf("%s/n", Data); <br />} <br />else <br />{ <br />if (rc != SQL_NO_DATA) <br />{ <br />DisplayError(SQL_HANDLE_STMT, hStmt, "SQLFetch"); <br />} <br />} <br />} <br /> <br /> <br /> <br />printf( "/nFirst Result Set - Hit Return to Continue/n"); <br />charptr = gets ((char *)error); <br /> <br /> <br /> <br />/* <br />* Get the Next Result Set <br />*/ <br />rc = SQLMoreResults( hStmt ); <br />if (rc != SQL_SUCCESS) <br />{ <br />DisplayError(SQL_HANDLE_STMT, hStmt, "SQLMoreResults"); <br />} <br /> <br /> <br /> <br />/* <br />* Get the data for Result Set 2 <br />*/ <br />printf( "/nManagers/n/n"); <br />while ( rc == SQL_SUCCESS ) <br />{ <br />rc = SQLFetch( hStmt ); <br />if ( rc == SQL_SUCCESS ) <br />{ <br />printf("%s/n", Data); <br />} <br />else <br />{ <br />if (rc != SQL_NO_DATA) <br />{ <br />DisplayError(SQL_HANDLE_STMT, hStmt, "SQLFetch"); <br />} <br />} <br />} <br /> <br /> <br /> <br />printf( "/nSecond Result Set - Hit Return to Continue/n"); <br />charptr = gets ((char *)error); <br /> <br /> <br /> <br />/* <br />* Should Be No More Results Sets <br />*/ <br />rc = SQLMoreResults( hStmt ); <br />if (rc != SQL_NO_DATA) <br />{ <br />DisplayError(SQL_HANDLE_STMT, hStmt, "SQLMoreResults"); <br />} <br /> <br /> <br /> <br />/* <br />* Drop the Package <br />*/ <br />lstrcpy( (char *) pSqlStmt, "DROP PACKAGE ODBCRefCur"); <br />rc = SQLExecDirect(hStmt, pSqlStmt, lstrlen((char *)pSqlStmt)); <br /> <br /> <br /> <br />/* <br />* Free handles close connections to the database <br />*/ <br />SQLFreeHandle( SQL_HANDLE_STMT, hStmt ); <br />SQLDisconnect( hDbc ); <br />SQLFreeHandle( SQL_HANDLE_DBC, hDbc ); <br />SQLFreeHandle( SQL_HANDLE_ENV, hEnv ); <br /> <br /> <br /> <br />printf( "/nAll Done - Hit Return to Exit/n"); <br />charptr = gets ((char *)error); <br />return(0); <br />} <br /> <br /> <br /> <br />/* <br />* Display Error Messages <br />*/ <br />void DisplayError( SWORD HandleType, SQLHANDLE hHandle, char *Module ) <br />{ <br /> <br /> <br /> <br />SQLCHAR MessageText[255]; <br />SQLCHAR SQLState[80]; <br />SQLRETURN rc=SQL_SUCCESS; <br />LONG NativeError; <br />SWORD RetLen; <br />SQLCHAR error[25]; <br />char *charptr; <br /> <br /> <br /> <br />rc = SQLGetDiagRec(HandleType, <br />hHandle, <br />1, <br />SQLState, <br />&amp;NativeError, <br />MessageText, <br />255, <br />&amp;RetLen); <br /> <br /> <br /> <br />printf( "Failure Calling %s/n", Module ); <br />if (rc == SQL_SUCCESS || rc == SQL_SUCCESS_WITH_INFO) <br />{ <br />printf( "/t/t/t State: %s/n", SQLState); <br />printf( "/t/t/t Native Error: %d/n", NativeError ); <br />printf( "/t/t/t Error Message: %s/n", MessageText ); <br />} <br /> <br />printf( "/nHit Return to Exit/n"); <br />charptr = gets ((char *)error); <br /> <br /> <br /> <br />exit(1); <br />}<br /></pre></div>
<!-- class="sect2" -->
<a id="BABJCDGE" name="BABJCDGE"></a><a id="ADFNS1195" name="ADFNS1195"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">EXEC構文の有効化</h3>
<p>このオプションを有効にすると、変更なしに変換可能な場合、Oracle ODBC Driverによって、SQL Server <code>EXEC</code>文の構文が対応するOracleプロシージャ・コールに変換されます。</p>
<p>SQL Serverプロシージャの絶対名は最大4つの識別子から構成されます。</p>
<ul>
<li>
<p>サーバー名</p>
</li>
<li>
<p>データベース名</p>
</li>
<li>
<p>所有者名</p>
</li>
<li>
<p>プロシージャ名</p>
</li>
</ul>
<p>名称のフォーマットは次のとおりです。</p>
<pre xml:space="preserve" class="oac_no_warn">[[[server.][database].][owner_name].]procedure_name<br /></pre>
<p>SQL ServerデータベースからOracleへの移行時、それぞれのSQL Serverプロシージャ(またはファンクション)定義は、対応するOracle構文に変換され、Oracleスキーマに定義されます。移行されたプロシージャは次の3つの方法のうちのいずれか1つの方法で再編(およびスキーマ内で作成)されます。</p>
<ul>
<li>
<p>全プロシージャは、1つのスキーマに移行されます(デフォルト・オプション)。</p>
</li>
<li>
<p>1つのSQL Serverデータベースに定義されたすべてのプロシージャは、そのデータベース名のスキーマに移行されます。</p>
</li>
<li>
<p>1人のユーザーに所有されるすべてのプロシージャは、そのユーザー名のスキーマに移行されます。</p>
</li>
</ul>
<p>これら3つのプロシージャ移行編成を行うには、変換するプロシージャに対し、いずれかのスキーマ名オプションを指定します。変換されたOracleプロシージャ・コール内のオブジェクト名は、大/小文字の区別はしません。</p>
</div>
<!-- class="sect2" -->
<a id="BABGJGBA" name="BABGJGBA"></a><a id="ADFNS1196" name="ADFNS1196"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Oracle RAC環境における接続障害のイベント通知の有効化</h3>
<p>Oracle Real Application Clusters (Oracle RAC)データベース環境で接続障害が発生したときに、<code>SQLSetConnectAttr</code>関数の<code>SQL_ORCLATTR_FAILOVER_CALLBACK</code>および<code>SQL_ORCLATTR_FAILOVER_HANDLE</code>属性が設定されている場合、イベント通知が有効になります。どちらの属性も、<code>SQLSetConnectAttr</code>関数を使用して設定されます。新規属性のシンボルは、ファイルsqora.hで定義されています。</p>
<p><code>SQL_ORCLATTR_FAILOVER_CALLBACK</code>属性は、障害イベントが発生したときにコールするルーチンのアドレスを指定するために使用されます。</p>
<p><code>SQL_ORCLATTR_FAILOVER_HANDLE</code>属性は、コールバック・ルーチンでパラメータの1つとして渡されるコンテキスト・ハンドルを指定するために使用されます。この属性は、ODBCアプリケーションで障害イベントが発生している接続を判別するために必要です。</p>
<p>コールバック・ルーチンの関数プロトタイプは次のとおりです。</p>
<pre xml:space="preserve" class="oac_no_warn">void failover_callback(void *handle, SQLINTEGER fo_code)<br /></pre>
<p>'handle'パラメータは、<code>SQL_ORCLATTR_FAILOVER_HANDLE</code>属性により設定された値です。この属性が設定されていない場合、NULLが戻されます。</p>
<p><code>fo_code</code>パラメータにより、発生している障害イベントが識別されます。障害イベントは、OCIプログラミング・インタフェースで定義されているイベントに直接マップされます。発生する可能性があるイベントのリストを次に示します。</p>
<ul>
<li>
<p><code>ODBC_FO_BEGIN</code></p>
</li>
<li>
<p><code>ODBC_FO_ERROR</code></p>
</li>
<li>
<p><code>ODBC_FO_ABORT</code></p>
</li>
<li>
<p><code>ODBC_FO_REAUTH</code></p>
</li>
<li>
<p><code>ODBC_FO_END</code></p>
</li>
</ul>
<p>この機能の使用方法を示したサンプル・プログラムは次のとおりです。</p>
<pre xml:space="preserve" class="oac_no_warn">/*<br />  NAME<br />  ODBCCallbackTest<br /> <br />  DESCRIPTION<br />  Simple program to demonstrate the connection failover callback feature.<br /> <br />  PUBLIC FUNCTION(S)<br />  main<br /> <br />  PRIVATE FUNCTION(S)<br /> <br />  NOTES<br /> <br />  Command Line: ODBCCallbackTest filename [odbc-driver]<br /> <br />*/<br /> <br />#include &lt;windows.h&gt;<br />#include &lt;tchar.h&gt;<br />#include &lt;malloc.h&gt;<br />#include &lt;stdio.h&gt;<br />#include &lt;string.h&gt;<br />#include &lt;sql.h&gt;<br />#include &lt;sqlext.h&gt;<br />#include "sqora.h"<br /> <br />/*<br />** Function Prototypes<br />*/<br />void display_errors(SQLSMALLINT HandleType, SQLHANDLE Handle);<br />void failover_callback(void *Handle, SQLINTEGER fo_code);<br /> <br />/*<br />** Macros<br />*/<br />#define ODBC_STS_CHECK(sts) \<br />  if (sts != SQL_SUCCESS) \<br />{ \<br />  display_errors(SQL_HANDLE_ENV, hEnv); \<br />  display_errors(SQL_HANDLE_DBC, hDbc); \<br />  display_errors(SQL_HANDLE_STMT, hStmt); \<br />  return FALSE; \<br />}<br /> <br />/*<br />** ODBC Handles<br />*/<br />SQLHENV *hEnv = NULL; // ODBC Environment Handle<br />SQLHANDLE *hDbc = NULL; // ODBC Connection Handle<br />SQLHANDLE *hStmt = NULL; // ODBC Statement Handle<br /> <br />/*<br />** Connection Information<br />*/<br />TCHAR *dsn = _T("odbctest");<br />TCHAR *uid = _T("scott");<br />TCHAR *pwd = _T("tiger");<br />TCHAR *szSelect = _T("select * from emp");<br /> <br />/*<br />** MAIN Routine<br />*/<br />main(int argc, char **argv)<br />{<br />  SQLRETURN rc;<br /> <br />  /*<br />  ** Allocate handles<br />  */<br />  rc = SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, (SQLHANDLE *)&amp;hEnv);<br />  ODBC_STS_CHECK(rc)<br /> <br />  rc = SQLSetEnvAttr(hEnv, SQL_ATTR_ODBC_VERSION, (SQLPOINTER)SQL_OV_ODBC3, 0);<br />  ODBC_STS_CHECK(rc);<br /> <br />  rc = SQLAllocHandle(SQL_HANDLE_DBC, hEnv, (SQLHANDLE *)&amp;hDbc);<br />  ODBC_STS_CHECK(rc);<br /> <br />  /*<br />  ** Connect to the database<br />  */<br />  rc = SQLConnect(hDbc, dsn, (SQLSMALLINT)_tcslen(dsn),<br />  uid, (SQLSMALLINT)_tcslen(uid),<br />  pwd, (SQLSMALLINT)_tcslen(pwd));<br />  ODBC_STS_CHECK(rc);<br /> <br />  /*<br />  ** Set the connection failover attributes<br />  */<br />  rc = SQLSetConnectAttr(hDbc, SQL_ORCLATTR_FAILOVER_CALLBACK, &amp;failover_callback, 0);<br />  ODBC_STS_CHECK(rc);<br /> <br />  rc = SQLSetConnectAttr(hDbc, SQL_ORCLATTR_FAILOVER_HANDLE, hDbc, 0);<br />  ODBC_STS_CHECK(rc);<br /> <br />  /*<br />  ** Allocate the statement handle<br />  */<br />  rc = SQLAllocHandle(SQL_HANDLE_STMT, hDbc, (SQLHANDLE *)&amp;hStmt);<br />  ODBC_STS_CHECK(rc);<br /> <br />  /*<br />  ** Wait for connection failovers<br />  */<br />  while (TRUE)<br />  {<br />  Sleep(5000);<br /> <br />  rc = SQLExecDirect(hStmt,szSelect, _tcslen(szSelect));<br />  ODBC_STS_CHECK(rc);<br /> <br />  rc = SQLFreeStmt(hStmt, SQL_CLOSE);<br />  ODBC_STS_CHECK(rc);<br />  }<br /> <br />  /*<br />  ** Free up the handles and close the connection<br />  */<br />  rc = SQLFreeHandle(SQL_HANDLE_STMT, hStmt);<br />  ODBC_STS_CHECK(rc);<br /> <br />  rc = SQLDisconnect(hDbc);<br />  ODBC_STS_CHECK(rc);<br /> <br />  rc = SQLFreeHandle(SQL_HANDLE_DBC, hDbc);<br />  ODBC_STS_CHECK(rc);<br /> <br />  rc = SQLFreeHandle(SQL_HANDLE_ENV, hEnv);<br />  ODBC_STS_CHECK(rc);<br /> <br />  return TRUE;<br />}<br /> <br />/*<br />** Failover Callback Routine<br />*/<br />void failover_callback(void *Handle, SQLINTEGER fo_code)<br />{<br />  switch (fo_code) {<br /> <br />  case ODBC_FO_BEGIN:<br />  printf("ODBC_FO_BEGIN recevied\n");<br />  break;<br /> <br />  case ODBC_FO_ERROR:<br />  printf("ODBC_FO_ERROR recevied\n");<br />  break;<br /> <br />  case ODBC_FO_ABORT:<br />  printf("ODBC_FO_ABORT recevied\n");<br />  break;<br /> <br />  case ODBC_FO_REAUTH:<br />  printf("ODBC_FO_REAUTH recevied\n");<br />  break;<br /> <br />  case ODBC_FO_END:<br />  printf("ODBC_FO_END recevied\n");<br />  break;<br /> <br />  default:<br />  printf("Invalid or unknown ODBC failover code recevied\n");<br />  break;<br /> <br />  };<br /> <br />  return;<br /> <br />}<br /> <br />/*<br />** Retrieve the errors associated with the handle passed<br />** and display them.<br />*/<br />void display_errors(SQLSMALLINT HandleType, SQLHANDLE Handle)<br />{<br />  SQLTCHAR MessageText[256];<br />  SQLTCHAR SqlState[5+1];<br />  SQLSMALLINT i=1;<br />  SQLINTEGER NativeError;<br />  SQLSMALLINT TextLength;<br />  SQLRETURN sts = SQL_SUCCESS;<br /> <br />  if (Handle == NULL) return;<br /> <br />  /* Make sure all SQLState text is null terminated */<br />  SqlState[5] = '\0';<br /> <br />  /*<br />  ** Fetch and display all diagnostic records that exist for this handle<br />  */<br />  while (sts == SQL_SUCCESS)<br />  {<br />  NativeError = 0;<br />  TextLength = 0;<br />  sts = SQLGetDiagRec(HandleType, Handle, i, SqlState, &amp;NativeError,<br />  (SQLTCHAR *)&amp;MessageText, sizeof(MessageText),<br />  &amp;TextLength);<br /> <br />  if (sts == SQL_SUCCESS)<br />  {<br />  printf("[%s]%s\n", SqlState, MessageText);<br />  if (NativeError != 0)<br />  {<br />  printf("Native Error Code: %d\n", NativeError);<br />  }<br />  i++;<br />  }<br />  }<br /> <br />  return;<br />}<br /></pre></div>
<!-- class="sect2" -->
<a id="BABDDGBE" name="BABDDGBE"></a><a id="ADFNS315" name="ADFNS315"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">ODBCを通じた暗黙的結果機能の使用</h3>
<p>このオプションは、サード・パーティODBCアプリケーションをOracleデータベースに移行し、前のベンダーでサポートされている暗黙的結果機能を使用する場合に使用します。Oracle ODBC Driverでは、ストアド・プロシージャまたは匿名PL/SQLブロックでの暗黙的結果がサポートされます。現在のリリースでは、暗黙的結果は<code>SELECT</code>文でのみ戻されます。</p>
<p>次のコード例は、暗黙的結果に匿名SQLスクリプトを使用したODBCテスト・ケースの例を示しています。</p>
<pre xml:space="preserve" class="oac_no_warn">const char *query1="declare \<br />                  c1 sys_refcursor; \<br />                  c2 sys_refcursor; \<br />                  begin \<br />                  open c1 for select empno,ename from emp where rownum&lt;=3; \<br />                  dbms_sql.return_result(c1); \<br />                  open c2 for select empno,ename from emp where rownum&lt;=3; \<br />                  dbms_sql.return_result(c2); end; ";<br /> <br />int main( )<br />{<br />  ...<br />   ...<br /> //Allocate all required handles and establish a connection to the database.<br /> <br /> //Prepare and execute the above anonymous PL/SQL block<br />    SQLPrepare (hstmt, (SQLCHAR *) query1, SQL_NTS);<br />    SQLExecute(hstmt);<br /> <br /> //Bind the columns for the results from the first SELECT statement in an anonymous block.<br />    SQLBindCol (hstmt, 1, SQL_C_ULONG, &amp;eno, 0, &amp;jind);<br />    SQLBindCol (hstmt, 2, SQL_C_CHAR, empname, sizeof (empname),&amp;enind);<br /> <br /> //Fetch implicit results through the SQLFetch( ) call.<br />    while((retCode = SQLFetch(hstmt)) != SQL_NO_DATA)<br />    {<br /> //Do whatever you want to do with the data.<br />    }<br /> <br />     retCode = SQLMoreResults(hstmt);<br /> <br />     if(retCode == SQL_SUCCESS)<br />    {<br />      printf("SQLMoreResults returned with SQL_SUCCESS\n");<br /> <br /> //Bind the columns for the results from the second SELECT statement in an anonymous block.<br />    SQLBindCol (hstmt, 1, SQL_C_ULONG, &amp;eno, 0, &amp;jind);<br />    SQLBindCol (hstmt, 2, SQL_C_CHAR, empname, sizeof (empname),&amp;enind);<br /> <br /> //Fetch implicit results through the SQLFetch( ) call.<br />    while((retCode = SQLFetch(hstmt)) != SQL_NO_DATA)<br />    {<br /> //Do whatever you want to do with data.<br />    }<br />  }<br />}<br /></pre></div>
<!-- class="sect2" -->
<a id="BABBCCDD" name="BABBCCDD"></a><a id="ADFNS1197" name="ADFNS1197"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">サポートされる機能</h3>
<ul>
<li>
<p><a href="#BABBCJCB">API準拠</a></p>
</li>
<li>
<p><a href="#BABHEGBH">ODBC API関数の実装</a></p>
</li>
<li>
<p><a href="#BABIDAGF">ODBC SQL構文の実装</a></p>
</li>
<li>
<p><a href="#BABEJGEG">データ型の実装(プログラミング)</a></p>
</li>
</ul>
<a id="BABBCJCB" name="BABBCJCB"></a><a id="ADFNS1198" name="ADFNS1198"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">API準拠</h4>
<p>Oracle ODBC Driverのリリース9.2.0.0.0以降では、すべてのコア、レベル2およびレベル1関数をサポートしています。</p>
<p>さらに、Oracle ODBC Driverのリリース9.2.0.0.0以降では、変換DLLをサポートしています。</p>
<p>次のトピックでは、Oracle ODBC Driverで実装されているODBC API関数について説明します。</p>
<a id="ADFNS1199" name="ADFNS1199"></a>
<p class="subhead2">上級ユーザー向け関連項目</p>
<p><a href="#BABCCDFB">エラー・メッセージ</a></p>
<a id="ADFNS1200" name="ADFNS1200"></a>
<p class="subhead2">プログラマ向け関連項目</p>
<p><a href="#BABHEGBH">ODBC API関数の実装</a></p>
</div>
<!-- class="sect3" -->
<a id="BABHEGBH" name="BABHEGBH"></a><a id="ADFNS1212" name="ADFNS1212"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">ODBC API関数の実装</h4>
<div class="tblformal"><a id="ADFNS1213" name="ADFNS1213"></a><a id="sthref14" name="sthref14"></a><a id="BABIIHAC" name="BABIIHAC"></a>
<p class="titleintable">表1-7 Oracle ODBC Driverで特定の関数を実装する方法</p>
<table border="1" cellpadding="3" cellspacing="0" class="Formal" dir="ltr" frame="hsides" rules="groups" summary="この表は、Oracle ODBC Driverが関数を実装する方法を示したものです。" title="Oracle ODBC Driverで特定の関数を実装する方法" width="100%">
<col width="31%" />
<col width="1*" />
<thead>
<tr align="left" valign="top">
<th id="r1c1-t17" align="left" valign="bottom">関数</th>
<th id="r1c2-t17" align="left" valign="bottom">説明</th>
</tr>
</thead>
<tbody>
<tr align="left" valign="top">
<td id="r2c1-t17" headers="r1c1-t17" align="left">
<p><code>SQLConnect</code></p>
</td>
<td headers="r2c1-t17 r1c2-t17" align="left">
<p>SQLConnectには、DBQ、ユーザーIDおよびパスワードのみが必要です。</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r3c1-t17" headers="r1c1-t17" align="left">
<p><code>SQLDriverConnect</code></p>
</td>
<td headers="r3c1-t17 r1c2-t17" align="left">
<p>SQLDriverConnectは、DSN、DBQ、UIDおよびPWDキーワードを使用します。</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r4c1-t17" headers="r1c1-t17" align="left">
<p><code>SQLMoreResults</code></p>
</td>
<td headers="r4c1-t17 r1c2-t17" align="left">
<p>暗黙的結果のODBCサポートを実装します。これは、リリース12.1で新規に実装されたAPIです。詳細は、<code><a href="http://msdn.microsoft.com/en-us/library/ms714673%28v=VS.85%29.aspx">http://msdn.microsoft.com/en-us/library/ms714673(v=VS.85).aspx</a></code>を参照してください。</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r5c1-t17" headers="r1c1-t17" align="left">
<p><code>SQLSpecialColumns</code></p>
</td>
<td headers="r5c1-t17 r1c2-t17" align="left">
<p><code>SQLSpecialColumns</code>は、<code>SQL_BEST_ROWID</code>属性を指定してコールされると、常にROWID列を戻します。</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r6c1-t17" headers="r1c1-t17" align="left">
<p><code>SQLProcedures</code>および<code>SQLProcedureColumns</code></p>
</td>
<td headers="r6c1-t17 r1c2-t17" align="left">
<p>次の項を参照してください。</p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r7c1-t17" headers="r1c1-t17" align="left">
<p>すべてのカタログ関数</p>
</td>
<td headers="r7c1-t17 r1c2-t17" align="left">
<p><code>SQL_ATTR_METADATA_ID</code>文属性が<code>SQL_TRUE</code>に設定されている場合、文字列引数は識別子引数として扱われ、大/小文字の区別はされません。この場合は、アンダースコア("_")やパーセント記号("%")は実際の文字として扱われ、検索文字列として見なされません。この属性が<code>SQL_FALSE</code>に設定されている場合、通常の引数またはパターン値の引数となり文字どおりに扱われ、大/小文字は区別されます。</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect3" -->
<a id="BABIDAGF" name="BABIDAGF"></a><a id="ADFNS1214" name="ADFNS1214"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">ODBC SQL構文の実装</h4>
<p>比較の述語に比較の第2式としてパラメータ・マーカーがあり、そのパラメータの値が<code>SQLBindParameter</code>によって<code>SQL_NULL_DATA</code>に設定されている場合、比較は失敗します。これはODBC SQLのNULL述語構文と一致しています。</p>
</div>
<!-- class="sect3" -->
<a id="BABEJGEG" name="BABEJGEG"></a><a id="ADFNS1215" name="ADFNS1215"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">データ型の実装(プログラミング)</h4>
<p>プログラマにとって特に注意が必要なのは、<code>CHAR</code>、<code>VARCHAR</code>および<code>VARCHAR2</code>データ型の実装です。</p>
<p><code>SQLGetTypeInfo</code>は、<code>SQL_VARCHAR</code>のfSqlType値に対し、Oracleデータベース・データ型である<code>VARCHAR2</code>を戻します。また、<code>SQLGetTypeInfo</code>は、<code>SQL_CHAR</code>のfSqlType値に対しては、Oracleデータベース・データ型である<code>CHAR</code>を戻します。</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABIFIGA" name="BABIFIGA"></a><a id="ADFNS1216" name="ADFNS1216"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Unicodeサポート</h3>
<ul>
<li>
<p><a href="#BABDBAFE">ODBC環境内のUnicodeサポート</a></p>
</li>
<li>
<p><a href="#BABCICFJ">ODBC API内でのUnicodeサポート</a></p>
</li>
<li>
<p><a href="#BABFEHCB">ドライバ・マネージャのUnicode機能</a></p>
</li>
<li>
<p><a href="#BABECFEA">SQLGetDataのパフォーマンス</a></p>
</li>
<li>
<p><a href="#BABEADIA">Unicodeの例</a></p>
</li>
</ul>
<a id="BABDBAFE" name="BABDBAFE"></a><a id="ADFNS1217" name="ADFNS1217"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">ODBC環境内のUnicodeサポート</h4>
<p>MicrosoftまたはunixODBC ODBCドライバ・マネージャ(ドライバ・マネージャ)によって、Unicodeをサポートしているかどうかに関係なく、すべてのODBCドライバがUnicode対応しているように動作します。これにより、下位のODBCドライバでUnicodeが使用可能かどうかに依存せずに、ODBCアプリケーションを作成することができます。</p>
<p>ドライバ・マネージャがANSI ODBCドライバ用にUnicodeサポートをエミュレートできるのは、Unicodeデータとローカル・コード・ページとの間の変換に限られています。ドライバ・マネージャがUnicodeからローカル・コード・ページに変換するとき、データが失われる可能性があります。完全なUnicodeサポートは、ODBCドライバがUnicodeをサポートしないかぎり不可能です。Oracle ODBC DriverはUnicodeをフル・サポートしています。</p>
</div>
<!-- class="sect3" -->
<a id="BABCICFJ" name="BABCICFJ"></a><a id="ADFNS1218" name="ADFNS1218"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">ODBC API内でのUnicodeサポート</h4>
<p>ODBC APIは、"W"と"A"という決まった接尾辞によって、UnicodeおよびANSIエントリ・ポイントの両方をサポートします。ODBCアプリケーションの開発者は、明示的に接尾辞によってエントリ・ポイントをコールする必要はありません。UNICODEおよび_UNICODEプリプロセッサ定義を指定して、ODBCアプリケーションをコンパイルすると、適切な関数コールを行います。たとえば、<code>SQLPrepare</code>コールは<code>SQLPrepareW</code>としてコンパイルされます。</p>
<p>アプリケーションが入力パラメータをUnicodeでエンコードするように指定したり、列データをUnicodeで返すように要求できるようにするために、Cデータ型である<code>SQL_C_WCHAR</code>がODBCインタフェースに追加されました。<code>SQL_C_TCHAR</code>マクロはUnicodeとANSIの両方でビルドする必要のあるアプリケーションに便利です。<code>SQL_C_TCHAR</code>マクロは、Unicodeアプリケーションの場合は<code>SQL_C_WCHAR</code>にコンパイルされ、ANSIアプリケーションの場合は<code>SQL_C_CHAR</code>にコンパイルされます。</p>
<p>SQLデータ型の<code>SQL_WCHAR</code>、<code>SQL_WVARCHAR</code>および<code>SQL_WLONGVARCHAR</code>は、表内でUnicodeと定義されている列を表すために、ODBCインタフェースに追加されています。これらの値は、<code>SQLDescribeCol</code>、<code>SQLColAttribute</code>、<code>SQLColumns</code>および<code>SQLProcedureColumns</code>コールから返されます。</p>
<p>Unicodeエンコードは、SQL列型<code>NCHAR</code>、<code>NVARCHAR2</code>および<code>NCLOB</code>についてサポートされています。また、SQL列型<code>CHAR</code>および<code>VARCHAR2</code>についても、キャラクタ・セマンティクスが列定義で指定されている場合は、Unicodeエンコードがサポートされます。</p>
<p>Oracle ODBC DriverはこれらのSQL列型をサポートしており、これらをODBC SQLデータ型にマップします。</p>
<div class="tblformal"><a id="ADFNS1219" name="ADFNS1219"></a><a id="sthref15" name="sthref15"></a><a id="BABJAEBG" name="BABJAEBG"></a>
<p class="titleintable">表1-8 サポートされるSQLデータ型および対応するODBC SQLデータ型</p>
<table border="1" cellpadding="3" cellspacing="0" class="Formal" dir="ltr" frame="hsides" rules="groups" summary="この表では、サポートされるSQLデータ型および対応するODBC Driverデータ型を示しています。" title="サポートされるSQLデータ型および対応するODBC SQLデータ型" width="100%">
<col width="31%" />
<col width="1*" />
<thead>
<tr align="left" valign="top">
<th id="r1c1-t18" align="left" valign="bottom">SQLデータ型</th>
<th id="r1c2-t18" align="left" valign="bottom">ODBC SQLデータ型</th>
</tr>
</thead>
<tbody>
<tr align="left" valign="top">
<td id="r2c1-t18" headers="r1c1-t18" align="left">
<p><code>CHAR</code></p>
</td>
<td headers="r2c1-t18 r1c2-t18" align="left">
<p><code>SQL_CHAR</code>または<code>SQL_WCHAR</code> <a href="#sthref16" id="sthref16" name="sthref16" onclick='footdisplay(1,"\u003ccode\u003eCHAR\u003c/code\u003e maps to \u003ccode\u003eSQL_WCHAR\u003c/code\u003e if the character semantics were specified in the column definition and if the character set for the database is Unicode. ")'><sup class="tablefootnote">脚注1&nbsp;</sup></a></p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r3c1-t18" headers="r1c1-t18" align="left">
<p><code>VARCHAR2</code></p>
</td>
<td headers="r3c1-t18 r1c2-t18" align="left">
<p><code>SQL_VARCHAR</code>または<code>SQL_WVARCHAR</code> <a href="#sthref17" id="sthref17" name="sthref17" onclick='footdisplay(2,"\u003ccode\u003eVARCHAR2\u003c/code\u003e maps to \u003ccode\u003eSQL_WVARCHAR\u003c/code\u003e if the character semantics were specified in the column definition and if the character set for the database is Unicode.")'><sup class="tablefootnote">脚注2&nbsp;</sup></a></p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r4c1-t18" headers="r1c1-t18" align="left">
<p><code>NCHAR</code></p>
</td>
<td headers="r4c1-t18 r1c2-t18" align="left">
<p><code>SQL_WCHAR</code></p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r5c1-t18" headers="r1c1-t18" align="left">
<p><code>NVARCHAR2</code></p>
</td>
<td headers="r5c1-t18 r1c2-t18" align="left">
<p><code>SQL_WVARCHAR</code></p>
</td>
</tr>
<tr align="left" valign="top">
<td id="r6c1-t18" headers="r1c1-t18" align="left">
<p><code>NCLOB</code></p>
</td>
<td headers="r6c1-t18 r1c2-t18" align="left">
<p><code>SQL_WLONGVARCHAR</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p class="tablefootnote"><sup class="tablefootnote">脚注1&nbsp;</sup>キャラクタ・セマンティクスが列定義で指定されている場合およびデータベースのキャラクタ・セットがUnicodeの場合、<code>CHAR</code>は<code>SQL_WCHAR</code>にマップされます。</p>
<p class="tablefootnote"><sup class="tablefootnote">脚注2&nbsp;</sup>キャラクタ・セマンティクスが列定義で指定されている場合およびデータベースのキャラクタ・セットがUnicodeの場合、<code>VARCHAR2</code>は<code>SQL_WVARCHAR</code>にマップされます。</p>
</div>
<!-- class="sect3" -->
<a id="BABFEHCB" name="BABFEHCB"></a><a id="ADFNS1220" name="ADFNS1220"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">ドライバ・マネージャのUnicode機能</h4>
<p>ドライバ・マネージャは、ODBCドライバがUnicodeをサポートしていないことを検出すると、次を実行します。</p>
<ul>
<li>
<p>ANSI ODBCドライバをコールする前にUnicode用関数コールをANSI用関数コールに変換します。文字列引数はUnicodeからローカル・コード・ページに変換されます。たとえば、<code>SQLPrepareW</code>コールは<code>SQLPrepare</code>コールに変換されます。SQL文パラメータの文字列はUnicodeからローカル・コード・ページに変換されます。</p>
</li>
<li>
<p>文字データのリターン・パラメータを、ローカル・コード・ページからUnicodeに変換します。たとえば、<code>SQLColAttribute</code>を使用して列名を戻す場合です。</p>
</li>
<li>
<p><code>SQL_C_WCHAR</code>でバインドされた列に対し、データをローカル・コード・ページからUnicodeコード・ページに変換します。</p>
</li>
<li>
<p><code>SQL_C_WCHAR</code>でバインドされた入力パラメータに対し、データをUnicodeからローカル・コード・ページに変換します。</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="BABECFEA" name="BABECFEA"></a><a id="ADFNS1221" name="ADFNS1221"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">SQLGetDataのパフォーマンス</h4>
<p><code>SQLGetData</code>関数を使用すると、ODBCアプリケーションは、データのフェッチ後に、受け取る列のデータ型を指定できます。OCIでは、Oracle ODBC Driverがフェッチ前にデータ型を指定する必要があります。OCIの場合、Oracle ODBC Driverは、データベース内で定義されている列のデータ型の情報を使用し、OCI経由で列データをフェッチする最適な方法を決定します。</p>
<p>文字データを持つ列が<code>SQLBindCol</code>でバインドされていない場合、Oracle ODBC Driverは列をフェッチするためにUnicodeなのかローカル・コード・ページなのか決定する必要があります。ドライバは、デフォルトとして列をUnicodeで受け取ることが可能ですが、結果として不要な変換を2回行うことになります。たとえば、データベースでデータがANSIでエンコードされている場合、Oracle ODBC Driverにデータを送る際にANSIからUnicodeへ変換されるとします。ODBCアプリケーションが<code>SQL_C_CHAR</code>としてデータを要求すると、元のエンコーディングに戻すために、さらに変換が行われることになります。</p>
<p>データのフェッチでは、Oracleクライアントのデフォルトのエンコーディングが使用されます。しかし、ODBCアプリケーションは、<code>WCHAR</code>データ型として列またはパラメータをバインドすることにより、このデフォルトを上書きして、Unicodeとしてデータをフェッチする場合があります。</p>
</div>
<!-- class="sect3" -->
<a id="BABEADIA" name="BABEADIA"></a><a id="ADFNS1222" name="ADFNS1222"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Unicodeの例</h4>
<p>Oracle ODBC Driver自体がTCHARマクロを使用しているので、これを利用するために、ユーザーのODBCアプリケーション・プログラムではTCHARを使用することをお薦めします。</p>
<p>次のプログラムではTCHARの使用方法を示します。TCHARはUNICODEおよび_UNICODEを指定してコンパイルする場合は、<code>WCHAR</code>データ型になります。</p>
<ul>
<li>
<p><a href="#BABHJIII">例1 データベースへの接続</a></p>
</li>
<li>
<p><a href="#BABEDAGC">例2 単純なデータ取出し</a></p>
</li>
<li>
<p><a href="#BABDCEJH">例3 SQLGetDataを使用したデータ取出し(フェッチ後のバインド)</a></p>
</li>
<li>
<p><a href="#BABCJHID">例4 単純なデータ更新</a></p>
</li>
<li>
<p><a href="#BABJAAJH">例5 LONGデータ(CLOB)の更新と取出し</a></p>
</li>
</ul>
<a id="BABHJIII" name="BABHJIII"></a><a id="ADFNS1223" name="ADFNS1223"></a>
<p class="subhead2">例1 データベースへの接続</p>
<p><code>SQLConnect</code>に対してUnicodeリテラルを使用する以外、他との違いはありません。</p>
<pre xml:space="preserve" class="oac_no_warn">HENV envHnd;<br />HDBC conHnd<br />;<br />HSTMT stmtHnd;<br />RETCODE rc;<br /><br />rc = SQL_SUCCESS;<br /><br /> <br />// ENV is allocated<br />rc = SQLAllocEnv(&amp;envHnd);<br />// Connection Handle is allocated<br />rc = SQLAllocConnect(envHnd, &amp;conHnd);<br />rc = SQLConnect(conHnd, _T("stpc19"), SQL_NTS, _T("scott"), SQL_NTS, _T("tiger"),<br /> SQL_NTS);<br />.<br />.<br />.<br />if (conHnd)<br />SQLFreeConnect(conHnd);<br />if (envHnd)<br />  SQLFreeEnv(envHnd);<br /></pre>
<a id="BABEDAGC" name="BABEDAGC"></a><a id="ADFNS1224" name="ADFNS1224"></a>
<p class="subhead2">例2 単純なデータ取出し</p>
<p>次の例では、従業員名と職種を<code>EMP</code>表から取り出します。TCHAR対応のデータを各ODBC関数に指定する必要がある以外、ANSIの場合との違いはありません。Unicodeアプリケーションの場合は、<code>SQLBindCol</code>をコールするときにバッファの長さを<code>BYTE</code>長で指定する必要があります(例: <code>sizeof(ename)</code>)。</p>
<pre xml:space="preserve" class="oac_no_warn">/*<br />** Execute SQL, bind columns, and Fetch.<br />** Procedure:<br />**<br />** SQLExecDirect<br />** SQLBindCol<br />** SQLFetch<br />** <br />*/<br />static SQLTCHAR *sqlStmt = _T("SELECT ename, job FROM emp");<br />SQLTCHAR ename[50];<br />SQLTCHAR job[50];<br />SQLINTEGER enamelen, joblen;<br /> <br />_tprintf(_T("Retrieve ENAME and JOB using SQLBindCol 1.../n[%s]/n"), sqlStmt);<br /> <br />// Step 1: Prepare and Execute<br />rc = SQLExecDirect(stmtHnd, sqlStmt, SQL_NTS); // select<br />checkSQLErr(envHnd, conHnd, stmtHnd, rc);<br /> <br />// Step 2: Bind Columns<br />rc = SQLBindCol(stmtHnd,<br />1,<br />SQL_C_TCHAR,<br />ename,<br />sizeof(ename),<br />&amp;enamelen);<br />checkSQLErr(envHnd, conHnd, stmtHnd, rc);<br /> <br />rc = SQLBindCol(stmtHnd,<br />2,<br />SQL_C_TCHAR,<br />job,<br />sizeof(job),<br />&amp;joblen);<br />checkSQLErr(envHnd, conHnd, stmtHnd, rc);<br /> <br />do <br />{<br />// Step 3: Fetch Data<br />rc = SQLFetch(stmtHnd);<br />if (rc == SQL_NO_DATA)<br />break;<br />checkSQLErr(envHnd, conHnd, stmtHnd, rc);<br />_tprintf(_T("ENAME = %s, JOB = %s/n"), ename, job);<br />} while (1);<br />_tprintf(_T("Finished Retrieval/n/n"));<br /></pre>
<a id="BABDCEJH" name="BABDCEJH"></a><a id="ADFNS1225" name="ADFNS1225"></a>
<p class="subhead2">例3 SQLGetDataを使用したデータ取出し(フェッチ後のバインド)</p>
<p>この例では、<code>SQLGetData</code>の使用方法を説明します。ODBCプログラミングに精通していない場合は、OCIプログラムの場合と異なり、<code>SQLGetData</code>を使用することで、データをバインドする前にフェッチすることが可能です。Unicode固有の点に関しては、ANSIアプリケーションとの違いはありません。</p>
<pre xml:space="preserve" class="oac_no_warn">/*<br />** Execute SQL, bind columns, and Fetch.<br />** Procedure:<br />**<br />** SQLExecDirect<br />** SQLFetch<br />** SQLGetData<br />*/<br />static SQLTCHAR *sqlStmt = _T("SELECT ename,job FROM emp"); // same as Case 1.<br />SQLTCHAR ename[50];<br />SQLTCHAR job[50];<br /> <br />_tprintf(_T("Retrieve ENAME and JOB using SQLGetData.../n[%s]/n"), sqlStmt);<br />if (rc != SQL_SUCCESS)<br />{<br />_tprintf(_T("Failed to allocate STMT/n"));<br />goto exit2;<br />}<br /> <br />// Step 1: Prepare and Execute<br />rc = SQLExecDirect(stmtHnd, sqlStmt, SQL_NTS); // select<br />checkSQLErr(envHnd, conHnd, stmtHnd, rc);<br /> <br /><br />do <br />{<br /><br />// Step 2: Fetch<br />rc = SQLFetch(stmtHnd);<br />if (rc == SQL_NO_DAT<br />break;<br /><br />checkSQLErr(envHnd, conHnd, stmtHnd, rc);<br /><br /> <br />// Step 3: GetData<br />rc = SQLGetData(st<br />mtHnd, <br />1,<br />SQL_C_TCHAR,<br />(SQLPOINTER)ename,<br />sizeof(ename), <br />NULL);<br />checkSQLErr(envHnd, conHnd, stmtHnd, rc);<br />rc = SQLGetData(stmtHnd, <br />2,<br />SQL_C_TCHAR, <br />(SQLPOINTER)job,<br />sizeof(job), <br />NULL);<br />checkSQLErr(envHnd, conHnd, stmtHnd, rc);<br />_tprintf(_T("ENAME = %s, JOB = %s/n"), ename, job);<br />} while (1);<br />_tprintf(_T("Finished Retrieval/n/n"));<br /></pre>
<a id="BABCJHID" name="BABCJHID"></a><a id="ADFNS1226" name="ADFNS1226"></a>
<p class="subhead2">例4 単純なデータ更新</p>
<p>この例では、データ更新の方法を説明します。同様に、<code>SQLBindParameter</code>に対するデータ長は、Unicodeアプリケーションの場合でも<code>BYTE</code>長で指定します。</p>
<pre xml:space="preserve" class="oac_no_warn">/<br />*<br />** Execute SQL, bind columns, and Fetch.<br />** Procedure:<br />**<br />** SQLPrepare<br />** SQLBindParameter<br />** SQLExecute<br />*/<br />static SQLTCHAR *sqlStmt = _T("INSERT INTO emp(empno,ename,job) VALUES(?,?,?)");<br />static SQLTCHAR *empno = _T("9876"); // Emp No<br />static SQLTCHAR *ename = _T("ORACLE"); // Name<br />static SQLTCHAR *job = _T("PRESIDENT"); // Job<br /> <br />_tprintf(_T("Insert User ORACLE using SQLBindParameter.../n[%s]/n"), sqlStmt);<br /> <br />// Step 1: Prepar<br />rc = SQLPrepare(stmtHnd, sqlStmt, SQL_NTS); // select<br />checkSQLErr(envHnd, conHnd, stmtHnd, rc);<br /> <br />// Step 2: Bind Parameterrc = SQLBindParameter(stmtHnd, <br />1, <br />SQL_PARAM_INPUT,<br />SQL_C_TCHAR,<br />SQL_DECIMAL,<br />4, // 4 digit<br />0,<br />(SQLPOINTER)empno,<br />0,<br />NULL);<br />checkSQLErr(envHnd, conHnd, stmtHnd, rc);<br /> <br />rc = SQLBindParameter(stmtHnd, <br />2, <br />SQL_PARAM_INPUT,<br />SQL_C_TCHAR,<br />SQL_CHAR,<br />lstrlen(ename)*sizeof(TCHAR),<br />0,<br />(SQLPOINTER)ename,<br />lstrlen(ename)*sizeof(TCHAR),<br />NULL);<br />checkSQLErr(envHnd, conHnd, stmtHnd, rc);<br /> <br />rc = SQLBindParameter(stmtHnd, <br />3, <br />SQL_PARAM_INPUT,<br />SQL_C_TCHAR,<br />SQL_CHAR,<br />lstrlen(job)*sizeof(TCHAR),<br />0,<br />(SQLPOINTER)job,<br />lstrlen(job)*sizeof(TCHAR),<br />NULL);<br />checkSQLErr(envHnd, conHnd, stmtHnd, rc);<br /> <br />// Step 3: Execute<br />rc = SQLExecute(stmtHnd);<br />checkSQLErr(envHnd, conHnd, stmtHnd, rc);<br /></pre>
<a id="BABJAAJH" name="BABJAAJH"></a><a id="ADFNS1227" name="ADFNS1227"></a>
<p class="subhead2">例5 LONGデータ(CLOB)の更新と取出し</p>
<p>この例は、Oracleの<code>CLOB</code>のような大きなデータの更新と取出しをする、最も複雑な場合の例です。データ長は常に<code>BYTE</code>長であるため、<code>BYTE</code>長を導出するには<code>strlen(TCHAR data)*sizeof(TCHAR)</code>が必要です。</p>
<pre xml:space="preserve" class="oac_no_warn">/*<br />** Execute SQL, bind columns, and Fetch.<br />** Procedure:<br />**<br />** SQLPrepare<br />** SQLBindParameter<br />** SQLExecute<br />** SQLParamData<br />** SQLPutData<br />**<br />** SQLExecDirect<br />** SQLFetch<br />** SQLGetData<br />*/<br />static SQLTCHAR *sqlStmt1 = _T("INSERT INTO clobtbl(clob1) VALUES(?)");<br />static SQLTCHAR *sqlStmt2 = _T("SELECT clob1 FROM clobtbl");<br />SQLTCHAR clobdata[1001];<br />SQLTCHAR resultdata[1001];<br />SQLINTEGER ind = SQL_DATA_AT_EXEC;<br />SQLTCHAR *bufp;<br />int clobdatalen, chunksize, dtsize, retchklen;<br /> <br />_tprintf(_T("Insert CLOB1 using SQLPutData.../n[%s]/n"), sqlStmt1);<br /> <br />// Set CLOB Data<br />{<br />int i;<br />SQLTCHAR ch;<br />for (i=0, ch=_T('A'); i&lt; sizeof(clobdata)/sizeof(SQLTCHAR); ++i, ++ch)<br />{<br />if (ch &gt; _T('Z'))<br />ch = _T('A');<br />clobdata[i] = ch;<br />}<br />clobdata[sizeof(clobdata)/sizeof(SQLTCHAR)-1] = _T('/0');<br />}<br />clobdatalen = lstrlen(clobdata); // length of characters<br />chunksize = clobdatalen / 7; // 7 times to put<br /> <br />// Step 1: Prepare<br />rc = SQLPrepare(stmtHnd, sqlStmt1, SQL_NTS);<br />checkSQLErr(envHnd, conHnd, stmtHnd, rc);<br /> <br />// Step 2: Bind Parameter with SQL_DATA_AT_EXEC<br />rc = SQLBindParameter(stmtHnd, <br />1, <br />SQL_PARAM_INPUT,<br />SQL_C_TCHAR,<br />SQL_LONGVARCHAR,<br />clobdatalen*sizeof(TCHAR),<br />0,<br />(SQLPOINTER)clobdata,<br />clobdatalen*sizeof(TCHAR),<br />&amp;ind);<br />checkSQLErr(envHnd, conHnd, stmtHnd, rc);<br /> <br />// Step 3: Execute<br />rc = SQLExecute(stmtHnd);<br />checkSQLErr(envHnd, conHnd, stmtHnd, rc);<br /> <br />// Step 4: ParamData (initiation)<br />rc = SQLParamData(stmtHnd, (SQLPOINTER*)&amp;bufp); // set value<br />checkSQLErr(envHnd, conHnd, stmtHnd, rc);<br /> <br />for (dtsize=0, bufp = clobdata;<br />dtsize &lt; clobdatalen;<br />dtsize += chunksize, bufp += chunksize)<br />{<br />int len;<br />if (dtsize+chunksize&lt;clobdatalen)<br />len = chunksize;<br />else<br />len = clobdatalen-dtsize;<br /> <br />// Step 5: PutData<br />rc = SQLPutData(stmtHnd, (SQLPOINTER)bufp, len*sizeof(TCHAR));<br />checkSQLErr(envHnd, conHnd, stmtHnd, rc);<br />}<br /> <br />// Step 6: ParamData (temination)<br />rc = SQLParamData(stmtHnd, (SQLPOINTER*)&amp;bufp);<br />checkSQLErr(envHnd, conHnd, stmtHnd, rc);<br /> <br />rc = SQLFreeStmt(stmtHnd, SQL_CLOSE);<br />_tprintf(_T("Finished Update/n/n"));<br />rc = SQLAllocStmt(conHnd, &amp;stmtHnd);<br />if (rc != SQL_SUCCESS)<br />{<br />_tprintf(_T("Failed to allocate STMT/n"));<br />goto exit2;<br />}<br /> <br />// Clear Result Data<br />memset(resultdata, 0, sizeof(resultdata));<br />chunksize = clobdatalen / 15; // 15 times to put<br /> <br />// Step 1: Prepare<br />rc = SQLExecDirect(stmtHnd, sqlStmt2, SQL_NTS); // select<br />checkSQLErr(envHnd, conHnd, stmtHnd, rc);<br /> <br />// Step 2: Fetch<br />rc = SQLFetch(stmtHnd);<br />checkSQLErr(envHnd, conHnd, stmtHnd, rc);<br /> <br />for(dtsize=0, bufp = resultdata;<br />dtsize &lt; sizeof(resultdata)/sizeof(TCHAR) &amp;&amp; rc != SQL_NO_DATA;<br />dtsize += chunksize-1, bufp += chunksize-1)<br />{<br />int len; // len should contain the space for NULL termination<br />if (dtsize+chunksize&lt;sizeof(resultdata)/sizeof(TCHAR))<br />len = chunksize;<br />else<br />len = sizeof(resultdata)/sizeof(TCHAR)-dtsize;<br /> <br />// Step 3: GetData<br />rc = SQLGetData(stmtHnd, <br />1,<br />SQL_C_TCHAR,<br />(SQLPOINTER)bufp,<br />len*sizeof(TCHAR), <br />&amp;retchklen);<br />}<br />if (!_tcscmp(resultdata, clobdata))<br />{<br />_tprintf(_T("Succeeded!!/n/n"));<br />}<br />else<br />{<br />_tprintf(_T("Failed!!/n/n"));<br />}<br /></pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABIIAIH" name="BABIIAIH"></a><a id="ADFNS1228" name="ADFNS1228"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">パフォーマンスおよびチューニング</h3>
<ul>
<li>
<p><a href="#BABBEJFD">一般的なODBCプログラミングのヒント</a></p>
</li>
<li>
<p><a href="#BABFHDGC">データソース構成オプション</a></p>
</li>
<li>
<p><a href="#BABDHDBB">DATEデータ型およびTIMESTAMPデータ型</a></p>
</li>
</ul>
<a id="BABBEJFD" name="BABBEJFD"></a><a id="ADFNS1229" name="ADFNS1229"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">一般的なODBCプログラミングのヒント</h4>
<p>この項では、ODBCアプリケーションのパフォーマンスを向上させるためのいくつかの一般的なプログラミングのヒントを記述しています。</p>
<ul>
<li>
<p>アプリケーションがデータソースからの接続および切断を頻繁に繰り返す場合、接続のプーリングを有効にします。再接続する場合に比べ、プールされた接続を使用する方がはるかに効果的です。</p>
</li>
<li>
<p>文を処理する回数を最小限にします。可能であれば、バインド・パラメータを使用して異なるパラメータ値に文を再使用できるようにします。<code>SQLExecute</code>ごとに文を処理するのに比べ、一度文を処理して数回実行する方がはるかに効果的です。</p>
</li>
<li>
<p>アプリケーションで取得しない列を<code>SELECT</code>文に含めないでください(特に<code>LONG</code>列)。データベース・サーバー・プロトコルの性質上、アプリケーションが列をバインドする場合、または<code>SQLGetData</code>をバインドする場合のいずれの場合も、<code>LONG</code>列が<code>SELECT</code>文に含まれている場合は、ODBCドライバはLONG列全体の内容をフェッチする必要があります。</p>
</li>
<li>
<p>データソースを更新しないトランザクションを実行中の場合は、ODBC <code>SQLSetConnectAttr</code>関数の<code>SQL_ATTR_ACCESS_MODE</code>属性を<code>SQL_MODE_READ_ONLY</code>に設定します。</p>
</li>
<li>
<p>ODBCのエスケープ句を使用していない場合は、ODBC <code>SQLSetConnectAttr</code>関数またはODBC <code>SQLSetStmtAttr</code>関数の<code>SQL_ATTR_NOSCAN</code>属性をTRUEに設定します。</p>
</li>
<li>
<p>非常に多くの行がある表からデータを取り出すには、ODBC <code>SQLFetch</code>関数のかわりにODBC <code>SQLFetchScroll</code>関数を使用します。</p>
</li>
<li>
<p>同じSQL文が複数回使用される場合には、OCI文キャッシュを有効にします(<code>StatementCache=T</code>)。</p>
</li>
<li>
<p><code>NUMBER</code>列を<code>FLOAT</code>としてバインドすると問合せの実行が高速になります(<code>BindAsFLOAT=T</code>)。</p>
</li>
<li>
<p><code>LONG</code>または<code>LONG RAW</code>のフェッチ中に、<code>MaxLargeData=&lt;value></code>に設定するとパフォーマンスが最適化されます。</p>
</li>
<li>
<p><code>Ref Cursor</code>を戻す小さなパッケージ・プロシージャに対して大量のコールが行われるアプリケーションで<code>UseOCIDescribeAny=T</code>と設定すると、パフォーマンスが向上します。</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="BABFHDGC" name="BABFHDGC"></a><a id="ADFNS1230" name="ADFNS1230"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">データソース構成オプション</h4>
<p>このトピックでは、次のODBCデータソース構成オプションのパフォーマンスに関連する事項を説明します。</p>
<ul>
<li>
<p><a href="#BABICDCG">結果セットの有効化</a></p>
</li>
<li>
<p><a href="#BABGGIBJ">LOBの有効化</a></p>
</li>
<li>
<p><a href="#BABJDGJB">TIMESTAMPをDATEとしてバインド</a></p>
</li>
<li>
<p><a href="#BABBBGDG">カーソル・クローズの有効化</a></p>
</li>
<li>
<p><a href="#BABFGFCH">スレッド・セーフティの有効化</a></p>
</li>
<li>
<p><a href="#BABCHCIA">フェッチ・バッファ・サイズ</a></p>
</li>
</ul>
<a id="BABICDCG" name="BABICDCG"></a><a id="ADFNS1231" name="ADFNS1231"></a>
<p class="subhead2">結果セットの有効化</p>
<p>このオプションは、プロシージャ・コールからの結果セット(たとえば、<code>RefCursor</code>)の戻しのサポートを有効にします。デフォルトでは結果セットが戻されます。</p>
<p>ODBCドライバは、<code>RefCursor</code>パラメータが含まれるかどうかを判断するために、データベース・サーバーへ問い合せてプロシージャのパラメータ・セットおよびそれらのデータ型を判断する必要があります。プロシージャが最初に処理および実行される際、この問合せが追加のネットワーク・ラウンド・トリップを発生させます。</p>
<a id="BABGGIBJ" name="BABGGIBJ"></a><a id="ADFNS1232" name="ADFNS1232"></a>
<p class="subhead2">LOBの有効化</p>
<p>このオプションは、LOBの挿入および更新を有効にします。デフォルトは有効です。</p>
<p>ODBCドライバは、LOBのパラメータが存在するかどうかを判断するために、<code>INSERT</code>文または<code>UPDATE</code>文で各パラメータのデータ型をデータベース・サーバーに問い合せる必要があります。<code>INSERT</code>または<code>UPDATE</code>文が最初に処理および実行される際、この問合せが追加のネットワーク・ラウンド・トリップを発生させます。</p>
<a id="BABJDGJB" name="BABJDGJB"></a><a id="ADFNS1233" name="ADFNS1233"></a>
<p class="subhead2">TIMESTAMPをDATEとしてバインド</p>
<p><code>SQL_TIMESTAMP</code>パラメータを適切なOracleデータ型でバインドします。このオプションが<code>TRUE</code>に設定されている場合、<code>SQL_TIMESTAMP</code>はOracleの<code>DATE</code>データ型でバインドされます。このオプションが<code>FALSE</code>に設定されている場合、<code>SQL_TIMESTAMP</code>はOracleの<code>TIMESTAMP</code>データ型でバインドされます(デフォルト)。</p>
<a id="BABBBGDG" name="BABBBGDG"></a><a id="ADFNS1234" name="ADFNS1234"></a>
<p class="subhead2">カーソル・クローズの有効化</p>
<p>ODBC関数の<code>SQL_CLOSE</code>オプション(<code>SQLFreeStmt</code>)は、文に関連するカーソルをクローズし、すべての未使用の結果を破棄すると想定されています。アプリケーションは、<code>SQLPrepare</code>なしで文を再実行しカーソルを再開させることができます。この結果、通常アプリケーションがしばらく休止状態になりますが、再び同じSQL文を再利用します。アプリケーションが休止状態の場合に、関連するサーバー・リソースを使用可能にする場合があります。</p>
<p>Oracle ODBC Driverが階層化されている<a href="#BABGCEAA">Oracle Call Interface</a>(OCI)は、カーソル・クローズ機能をサポートしていません。デフォルトでは、<code>SQL_CLOSE</code>オプションはOracle ODBC Driverには影響がありません。カーソルおよび関連のリソースは、データベース・サーバー上にオープンされた状態で存在します。</p>
<p>このオプションを有効に設定した場合、データベース・サーバー上の関連カーソルをクローズさせることができます。ただし、解析済のSQL文は破棄されてしまいます。ODBCアプリケーションは、<code>SQLPrepare</code>コールなしで再び文を実行することができます。ただし、実際にはODBCドライバは文を解析してからすべて実行することになります。このオプションを有効にした場合、一度文を解析し、それを繰り返して実行するアプリケーションのパフォーマンスには重大な影響があります。</p>
<p>サーバーの関連リソースを解放することが確実に必要である場合のみ、このオプションを有効にしてください。</p>
<a id="BABFGFCH" name="BABFGFCH"></a><a id="ADFNS1235" name="ADFNS1235"></a>
<p class="subhead2">スレッド・セーフティの有効化</p>
<p>アプリケーションがシングル・スレッドの場合、このオプションを無効にできます。デフォルトでは、ODBCドライバは、すべての内部構造(環境、接続、文)へのアクセスがスレッド・セーフティであることを保証しています。シングル・スレッドのアプリケーションは、このオプションを無効にすることにより、スレッド・セーフティのオーバーヘッドの一部を回避できます。このオプションを無効にすることにより、多少のパフォーマンスの改善がみられます。</p>
<a id="BABCHCIA" name="BABCHCIA"></a><a id="ADFNS1236" name="ADFNS1236"></a>
<p class="subhead2">フェッチ・バッファ・サイズ</p>
<p><a href="#BABEFEHG">「Oracle ODBCドライバ構成」ダイアログ・ボックス</a>の<a href="#BABFJIJI">「Oracle」オプション</a>・タブの「フェッチ・バッファ・サイズ」をバイト単位で設定します。この値は、単一の問合せでアプリケーション・プログラムがリクエストする行数に関係なく、ODBCドライバがOracleデータベースからクライアントのキャッシュに一度にプリフェッチしてパフォーマンスを向上させるデータの行数を決定するために必要なメモリー量です。</p>
<p>通常一度に20行未満をフェッチするアプリケーションでは、低速なネットワーク接続上で動作する場合や非常に負荷の高いサーバーにアクセスする場合には特に、レスポンス時間が向上します。これを大きく設定しすぎると、実際にはレスポンス時間が悪化したり、メモリーを大量に消費したりすることがあります。デフォルトは64,000バイトです。アプリケーションに最適な値を選択します。</p>
<div align="center">
<div class="inftblnote"><br />
<table border="1" cellpadding="3" cellspacing="0" class="Note oac_no_warn" frame="hsides" rules="groups" summary="" width="80%">
<tbody>
<tr>
<td align="left">
<p class="notep1">注意:</p>
<code>LONG</code>およびLOBデータ型がある場合、ODBCドライバのプリフェッチ行数は、フェッチ・バッファ・サイズに依存しません。<code>LONG</code>およびLOBデータ型では、パフォーマンスの改善が見込めず、過度のメモリー消費を引き起こす可能性があります。ODBCドライバは、<code>LONG</code>およびLOBデータ型が含まれる場合、フェッチ・バッファ・サイズを無視し、プリフェッチ行数を使用します。</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblnote" --></div>
</div>
<!-- class="sect3" -->
<a id="BABDHDBB" name="BABDHDBB"></a><a id="ADFNS1237" name="ADFNS1237"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">DATEデータ型およびTIMESTAMPデータ型</h4>
<p>索引を含む<code>DATE</code>列を<code>WHERE</code>句で使用すると、データベースのパフォーマンスに影響する場合があります。次に例を示します。</p>
<pre xml:space="preserve" class="oac_no_warn">SELECT * FROM EMP WHERE HIREDATE = ?<br /></pre>
<p>この例では<code>HIREDATE</code>列の索引を使用して、瞬時に問合せを実行できます。ただし、<code>HIREDATE</code>は実際には<code>DATE</code>値であり、ODBCドライバにより<code>TIMESTAMP</code>のパラメータ値が提供されるため、Oracleサーバーの問合せオプティマイザには変換機能を適用する必要があります。誤った結果(パラメータ値にゼロ以外の小数秒が含まれる場合に起こる可能性があります)を回避するには、オプティマイザで<code>HIREDATE</code>列への変換を適用し、次の文で終わるようにします。</p>
<pre xml:space="preserve" class="oac_no_warn">SELECT * FROM EMP WHERE TO_TIMESTAMP(HIREDATE) = ?<br /></pre>
<p>残念ながら、これにより<code>HIREDATE</code>列の索引の使用は無効になり、かわりにサーバーによる表のスキャンが順次実行されます。表に多くの列が含まれる場合、これには時間がかかります。この状況を回避するため、ODBCドライバには<code>「TIMESTAMPをDATEとしてバインド」</code>接続オプションが用意されています。このオプションが有効になっている場合、<code>SQL_TIMESTAMP</code>パラメータはODBCドライバによりOracleの<code>TIMESTAMP</code>データ型ではなく<code>DATE</code>データ型でバインドされます。これにより、問合せオプティマイザで<code>DATE</code>列の索引が使用できるようになります。</p>
<div align="center">
<div class="inftblnote"><br />
<table border="1" cellpadding="3" cellspacing="0" class="Note oac_no_warn" frame="hsides" rules="groups" summary="" width="80%">
<tbody>
<tr>
<td align="left">
<p class="notep1">注意:</p>
このオプションは、<code>DATE</code>列を<code>TIMESTAMP</code>列としてバインドするMicrosoft Accessや、その他同種のプログラムでの使用のみを目的としています。実際に<code>TIMESTAMP</code>列が存在する場合、またはデータの喪失が起こりうる場合には使用しないでください。Microsoft Accessでは、主キーとして選択されたあらゆる列を使用して、このような問合せが実行されています。</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblnote" --></div>
<a id="ADFNS1238" name="ADFNS1238"></a>
<p class="subhead2">関連トピック</p>
<p><a href="#BABBAEEH">データ型の実装</a></p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABJHHHH" name="BABJHHHH"></a><a id="ADFNS1239" name="ADFNS1239"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">用語集</h2>
<a id="BABECBJJ" name="BABECBJJ"></a><a id="ADFNS1240" name="ADFNS1240"></a>
<p class="subhead2">API</p>
<p>Application Program Interface。アプリケーションから基盤となっているプログラムまたはシステムの利用(つまり通信)を可能にする、プログラム関数またはコールのセット。</p>
<a id="ADFNS1241" name="ADFNS1241"></a>
<p class="subhead2">クライアント(Client)</p>
<p>クライアントは、定められたインタフェースを使用してサーバーが提供するTNSサービスを選択し、データにアクセスするためのソフトウェア・プログラムです。サーバーは、応答としてクライアントの要求の受信および処理を行い、その結果をクライアントに戻します。ODBCクライアント・アプリケーションは、ODBCドライバのAPIを使用してODBC関数をコールし、SQL文の送信および結果の取得を行います。</p>
<a id="BABJACEF" name="BABJACEF"></a><a id="ADFNS1242" name="ADFNS1242"></a>
<p class="subhead2">準拠レベル(Conformance Levels)</p>
<p>アプリケーションの中には、特定のレベルの機能をサポートしているドライバ、または特定のレベルの規格に合致しているドライバ以外は使用できないものがあります。たとえば、行セット内のカーソル位置を設定し、アプリケーションがその行セット内のデータを更新できるようにする機能です。これはApplication Program Interface (API)の準拠レベル1の機能の一部です。</p>
<p>ODBCドライバは、Core APIレベルとレベル1、レベル2の一部に準拠し、さらにSQL-99のコア仕様と広く互換性があります。ドライバは、定められた準拠レベルより上のレベルの機能の一部をサポートしている場合があります。</p>
<p>各準拠レベルに含まれる機能の詳細は、『Microsoft ODBC 3.52 Software Development Kit and Programmers Reference』を参照してください。</p>
<a id="BABFICBD" name="BABFICBD"></a><a id="ADFNS1243" name="ADFNS1243"></a>
<p class="subhead2">データソース(Data Source)</p>
<p>データソースには、ユーザーのアクセス対象のデータに関する情報と、そのデータへのアクセス方法に関する情報が含まれています。Oracle ODBC Driverにおいては、データソースはOracleデータベースの特定のインスタンスおよびOracleデータベースとの通信に使用するOracle Net Servicesコンポーネントの別名です。</p>
<a id="BABIIHGJ" name="BABIIHGJ"></a><a id="ADFNS1244" name="ADFNS1244"></a>
<p class="subhead2">DLL</p>
<p>ダイナミック・リンク・ライブラリ。1つ以上のアプリケーションが共通のタスクを実行できるようにするルーチンのセット。ODBCドライバは、WindowsプラットフォームではDLLで、UNIXプラットフォームでは共有オブジェクト(.so)ファイルです。</p>
<a id="ADFNS1245" name="ADFNS1245"></a>
<p class="subhead2">ドライバ・マネージャ</p>
<p>ドライバ・マネージャは、MicrosoftおよびunixODBCにより提供され、アプリケーションがODBC <code>SQLConnect</code>またはODBC <code>SQLDriverConnect</code>関数をコールするときに、アプリケーションに代わってドライバをロードします。</p>
<a id="ADFNS1246" name="ADFNS1246"></a>
<p class="subhead2">ネットワーク・トランスポート(Network Transports)</p>
<p>ネットワークは通信ソフトウェアとハードウェアから構成され、マシン上のOCIクライアントはネットワークを通じて別のコンピュータ・システム上のOracleサーバーと通信します。OCIクライアントからのメッセージ・リクエストとサーバーからのレスポンス・リクエストは、様々なネットワーク・トランスポートをサポートできるOracle Net Services通信リンク上を移動します。</p>
<a id="BABFCGBI" name="BABFCGBI"></a><a id="ADFNS1247" name="ADFNS1247"></a>
<p class="subhead2">ODBC</p>
<p>Open Database Connectivityの略。ドライバ・マネージャと複数のODBCドライバのセットで構成され、SQLを標準言語として使用してアプリケーションがデータにアクセスできるようにします。</p>
<a id="ADFNS1248" name="ADFNS1248"></a>
<p class="subhead2">ODBCアプリケーション(ODBC Application)</p>
<p>ODBCアプリケーションは処理を実行し、ODBC関数をコールしてSQL文を送信し、結果を取得します。アプリケーションは、それぞれ異なるデータソースにアクセスする複数のデータ・ドライバにアクセスできます。</p>
<a id="ADFNS1249" name="ADFNS1249"></a>
<p class="subhead2">ODBCドライバ(ODBC Driver)</p>
<p>MicrosoftのOpen Database Connectivity (ODBC)は、1つのアプリケーションが多くの異なるデータソースにアクセスできるようにする標準インタフェースを提供します。アプリケーションのソース・コードは、データソースごとに再コンパイルする必要がありません。ODBCドライバは、Windowsプラットフォーム上のダイナミック・リンク・ライブラリ(DLL)またはUNIXプラットフォーム上の共有オブジェクト(SO)であり、アプリケーションはこれをオンデマンドで呼び出してデータソースにアクセスできます。ODBCドライバは、アプリケーションを特定のデータソースにリンクし、ODBC関数コールの処理、特定のデータソースへのSQLリクエストの送信およびアプリケーションへの結果の返信を行います。リクエストが関連データソースでサポートされる構文に準拠するように、ODBCドライバが必要に応じてアプリケーションのリクエストを変更します。ドライバ・マネージャとODBCドライバは、アプリケーションからはODBC関数コールを処理する1つの単位のように見えます。Oracle ODBC Driverでは、Oracleデータベースにのみ読取りおよび書込みアクセスできます。</p>
<p>サード・パーティのオープン・ソース・ドライバ・マネージャ(DM)で動作するUNIXプラットフォーム用のODBCドライバもあります。Oracle ODBC Driverは、UNIXプラットフォームでは<code>unixODBC.org</code>で提供されるDMを使用して認定されています。プラットフォームの詳細は、<code>ODBC_Readme_Unix.html</code>ファイルを参照してください。</p>
<a id="ADFNS1250" name="ADFNS1250"></a>
<p class="subhead2">Oracle</p>
<p>Oracleは、高パフォーマンス、高可用性、スケーラブル、汎用、マルチユーザーのデータベース管理システムであり、様々なコンピュータ・オペレーティング・システムで稼働するオブジェクトで拡張されたリレーショナル・モデルに基づいています。Oracle Database 12gは、あらゆる規模の組織のビジネス・ニーズとITニーズを満たすように調整されたエディションから選択できます。フル・セットのユーティリティと業界標準のSQLデータ定義、さらにOracleデータベースを作成、問合せおよびメンテナンスできるデータ操作言語がサポートされます。Oracleは、VLDB、ハイエンドOLTPおよびデータ・ウェアハウス・アプリケーションをサポートし、Oracle Enterprise Manager GUIを使用した拡張管理機能とOracle Advanced Securityを使用した拡張セキュリティを含んでいます。</p>
<p>また、Oracleには、重要なトランザクション処理、データ・ウェアハウス、コンテンツ管理アプリケーションの最も厳しい要件を満たす様々なEnterprise Editionオプションが用意されています。これらのオプションに含まれるのは、Oracle Active Data Guard、Oracle Advanced Compression、Oracle Advanced Security、Oracle Database Vault、Oracle Data Mining、Oracle In-Memory Database Cache、Oracle Label Security、Oracle OLAP、Oracle Partitioning、Oracle Real Application Clusters、Real Application Testing、Oracle Spatial、Oracle Total Recall、Oracle Warehouse BuilderのEnterprise ETLオプション、Oracle Warehouse BuilderのData Qualityオプション、Oracle Warehouse Builderの接続、およびOracle Content Database Suiteです。</p>
<p>また、Oracleには、独特なトップダウンのアプリケーション管理方法でOracleデータベースを管理する、統合された管理ソリューションが備わっています。新しい自動管理機能により、時間がかかり、ミスの起きやすい管理タスクがなくなるため、データベース管理者は、パフォーマンスや可用性に関する問題ではなく、戦略的な運営目標に集中することができます。Oracleのデータベース管理パックには、Oracle Change Management Pack、Oracle Configuration Management Pack、Oracle Data Masking Pack、Oracle Diagnostic Pack、Oracle Provisioning and Patch Automation Pack、およびOracle Tuning Packが含まれます。</p>
<p>Oracleには、Oracle Audit Vault、Oracle Secure Backup、Oracle Programmer、Oracle TimesTen In-Memory Database、Oracle Berkeley DB、およびOracle Database Liteなどの様々な関連製品もあります。</p>
<a id="BABGCEAA" name="BABGCEAA"></a><a id="ADFNS1251" name="ADFNS1251"></a>
<p class="subhead2">Oracle Call Interface</p>
<p>Oracle Call Interface (OCI)は、標準ソフトウェア・ルーチン(プログラム・コール・インタフェース)のセットで、Oracleサーバーへのアクセスに使用します。OCIを使用することにより、高水準言語に直接Oracleコールを埋め込むことができます。</p>
<a id="BABFDACF" name="BABFDACF"></a><a id="ADFNS1252" name="ADFNS1252"></a>
<p class="subhead2">Oracle Net Services</p>
<p>オラクル社のネットワーク製品ファミリ。クライアント、サーバーおよびゲートウェイを透過的に統合し、業界標準または専用のネットワーク・プロトコルを使用して、統一された情報資源を配信します。</p>
<a id="BABFGCHB" name="BABFGCHB"></a><a id="ADFNS1253" name="ADFNS1253"></a>
<p class="subhead2">Oracle Net Configuration Assistant (NETCA)</p>
<p>各TNSサービス名の<code>tnsnames.ora</code>ファイル内のエントリを更新することによって、Oracle Net Servicesネットワークを簡単に構成および保守するためのユーティリティ。</p>
<a id="BABJABEH" name="BABJABEH"></a><a id="ADFNS1254" name="ADFNS1254"></a>
<p class="subhead2">SQL</p>
<p>Structured Query Language。国際的に受け入れられているリレーショナル・システムの規格であり、問合せだけでなく、データ定義、操作、セキュリティおよび参照整合性の一部の機能も扱っています。</p>
<a id="ADFNS1255" name="ADFNS1255"></a>
<p class="subhead2">TCP/IP</p>
<p>Transmission Control Protocol/Internet Protocol。TCP/IPは、プロセス間通信メカニズムの1つで、ネットワーク間でデータを共有するアプリケーションが使用します。TCPを利用すると、1つのマシン上のプロセスから別のマシン上のプロセスへデータ・ストリームを送信できます。TCPを実装したソフトウェアは、通常、オペレーティング・システムに常駐し、IPを使用してインターネット経由で情報を送信します。</p>
</div>
<!-- class="sect1" -->
<a id="BABCEBCD" name="BABCEBCD"></a><a id="ADFNS1256" name="ADFNS1256"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">著作権および商標</h2>
<p>この項の内容は次のとおりです。</p>
<ul>
<li>
<p><a href="#BABIICBI">著作権および商標について</a></p>
</li>
<li>
<p><a href="#BABIFHIA">アクセシビリティ・ステートメント</a></p>
</li>
</ul>
<a id="BABIICBI" name="BABIICBI"></a><a id="ADFNS1257" name="ADFNS1257"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">著作権および商標について</h3>
<p>Oracle ODBC Driver, リリース12.2</p>
<p>Copyright © 1993, 2015 Oracle.All rights reserved.</p>
<p>このソフトウェアおよび関連ドキュメントの使用と開示は、ライセンス契約の制約条件に従うものとし、知的財産に関する法律により保護されています。ライセンス契約で明示的に許諾されている場合もしくは法律によって認められている場合を除き、形式、手段に関係なく、いかなる部分も使用、複写、複製、翻訳、放送、修正、ライセンス供与、送信、配布、発表、実行、公開または表示することはできません。このソフトウェアのリバース・エンジニアリング、逆アセンブル、逆コンパイルは互換性のために法律によって規定されている場合を除き、禁止されています。</p>
<p>ここに記載された情報は予告なしに変更される場合があります。また、誤りが無いことの保証はいたしかねます。誤りを見つけた場合は、オラクル社までご連絡ください。</p>
<p>このソフトウェアまたは関連ドキュメントを、米国政府機関もしくは米国政府機関に代わってこのソフトウェアまたは関連ドキュメントをライセンスされた者に提供する場合は、次の通知が適用されます。</p>
<p>U.S. GOVERNMENT END USERS: Oracle programs, including any operating system, integrated software, any programs installed on the hardware, and/or documentation, delivered to U.S. Government end users are "commercial computer software" pursuant to the applicable Federal Acquisition Regulation and agency-specific supplemental regulations.As such, use, duplication, disclosure, modification, and adaptation of the programs, including any operating system, integrated software, any programs installed on the hardware, and/or documentation, shall be subject to license terms and license restrictions applicable to the programs.No other rights are granted to the U.S. Government.</p>
<p>このソフトウェアまたはハードウェアは様々な情報管理アプリケーションでの一般的な使用のために開発されたものです。このソフトウェアもしくはハードウェアは、危険が伴うアプリケーション(人的傷害を発生させる可能性があるアプリケーションを含む)への用途を目的として開発されていません。このソフトウェアもしくはハードウェアを危険が伴うアプリケーションで使用する際、安全に使用するために、適切な安全装置、バックアップ、冗長性(redundancy)、その他の対策を講じることは使用者の責任となります。このソフトウェアまたはハードウェアを危険が伴うアプリケーションで使用したことに起因して損害が発生しても、オラクル社およびその関連会社は一切の責任を負いかねます。</p>
<p>OracleおよびJavaはOracle Corporationおよびその関連企業の登録商標です。その他の名称は、それぞれの所有者の商標または登録商標です。</p>
<p>IntelおよびIntel XeonはIntel Corporationの商標または登録商標です。すべてのSPARCの商標はライセンスをもとに使用し、SPARC International, Inc.の商標または登録商標です。AMD、Opteron、AMDロゴ、AMD Opteronロゴは、Advanced Micro Devices, Inc.の商標または登録商標です。UNIXは、The Open Groupの登録商標です。</p>
<p>このソフトウェアまたはハードウェアおよびドキュメントは、第三者のコンテンツ、製品、サービスへのアクセス、あるいはそれらに関する情報を提供することがあります。オラクル社およびその関連会社は、第三者のコンテンツ、製品、サービスに関して一切の責任を負わず、いかなる保証もいたしません。オラクル社およびその関連会社は、第三者のコンテンツ、製品、サービスへのアクセスまたは使用によって損失、費用、あるいは損害が発生しても、一切の責任を負いかねます。</p>
<p class="alphabetanotice">このドキュメントはリリース前のものであり、デモおよび暫定使用のみを目的としています。このソフトウェアを使用するハードウェアに限定するものではありません。Oracle Corporation and its affiliates are not responsible for and expressly disclaim all warranties of any kind with respect to this documentation and will not be responsible for any loss,costs,or damages incurred due to the use of this documentation.</p>
<div class="revenuerecognitionnotice">
<p>このドキュメントの情報は、情報共有の目的のみに使用され、顧客諮問委員会の会員の立場で考慮されるか、ベータ・トライアル版契約のみに準じる必要があります。資料、規約または機能性を配信する義務はなく、購買決定に依存することはできないものとします。このドキュメントに記載されている開発、リリース、およびすべての機能または機能性の時期は、オラクル社の独自の判断に従うものとします。</p>
<p>このドキュメントは、ソフトウェアまたは印刷物などの形式にかかわらず、オラクル社の独占的な財産である機密情報を含みます。この機密資料は、Oracleソフトウェア使用許諾契約に基づいて提供され、その内容に同意する場合のみ使用できます。オラクル社の文書による事前承諾なしに、このドキュメントおよびここに含まれる情報を開示、コピー、再生、またはオラクル社外部の他者に配布することはできません。このドキュメントは使用許諾契約の一部ではなく、オラクル社の子会社またはアフィリエイトとの契約上の合意に組み込まれません。</p>
</div>
</div>
<!-- class="sect2" -->
<a id="BABIFHIA" name="BABIFHIA"></a><a id="ADFNS1258" name="ADFNS1258"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">アクセシビリティ・ステートメント</h3>
<p>オラクル社のアクセシビリティへの取組みの詳細は、Oracle Accessibility ProgramのWebサイト<code><a href="http://www.oracle.com/pls/topic/lookup?ctx=acc&amp;id=docacc">http://www.oracle.com/pls/topic/lookup?ctx=acc&amp;id=docacc</a></code>を参照してください。</p>
<a id="ADFNS1259" name="ADFNS1259"></a><a id="sthref18" name="sthref18"></a>
<p class="subhead2">Oracleサポートへのアクセス</p>
<p>Oracleのお客様は、My Oracle Supportにアクセスして電子サポートを受けることができます。詳細は、<code><a href="http://www.oracle.com/pls/topic/lookup?ctx=acc&amp;id=info">http://www.oracle.com/pls/topic/lookup?ctx=acc&amp;id=info</a></code>または<code><a href="http://www.oracle.com/pls/topic/lookup?ctx=acc&amp;id=trs">http://www.oracle.com/pls/topic/lookup?ctx=acc&amp;id=trs</a></code> (聴覚障害者向け)を参照してください。</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
<div class="footer">
<hr />
<table cellpadding="0" cellspacing="0" class="simple oac_no_warn" summary="" width="100%">
<col width="6%" />
<col width="6%" />
<col width="1*" />
<col width="6%" />
<tbody><tr>
<td align="center"><a href="toc.htm"><br /> <span class="icon">戻る</span></a>&nbsp;</td>
<td align="center"><span class="copyrightlogo">Copyright © 1993, 2015, Oracle and/or its affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.</span><br /> <a href="cpyr.htm"><span class="copyrightlogo">法律上の注意点</span></a></td>
<td align="right" valign="top"><a href="toc.htm"><br /> <span class="icon">目次</span></a></td>
</tr>
</tbody></table>
</div>
<!-- class="footer" -->
</body></html>
